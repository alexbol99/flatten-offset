{"version":3,"sources":["webpack://flatten-offset/webpack/universalModuleDefinition","webpack://flatten-offset/webpack/bootstrap","webpack://flatten-offset/./node_modules/flatten-interval-tree/index.js","webpack://flatten-offset/./node_modules/flatten-interval-tree/utils/constants.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/algorithms/distance.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/polygon.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/algorithms/ray_shooting.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/ray.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/face.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/edge.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/box.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/arc.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/segment.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/circle.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/line.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/vector.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/classes/point.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/data_structures/planar_set.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/utils/errors.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/utils/utils.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/node_modules/flatten-js/index.js","webpack://flatten-offset/./node_modules/flatten-boolean-op/index.js","webpack://flatten-offset/./node_modules/flatten-js/algorithms/distance.js","webpack://flatten-offset/./node_modules/flatten-js/classes/polygon.js","webpack://flatten-offset/./node_modules/flatten-js/algorithms/ray_shooting.js","webpack://flatten-offset/./node_modules/flatten-js/classes/ray.js","webpack://flatten-offset/./node_modules/flatten-js/classes/face.js","webpack://flatten-offset/./node_modules/flatten-js/classes/edge.js","webpack://flatten-offset/./node_modules/flatten-js/classes/box.js","webpack://flatten-offset/./node_modules/flatten-js/classes/arc.js","webpack://flatten-offset/./node_modules/flatten-js/classes/segment.js","webpack://flatten-offset/./node_modules/flatten-js/classes/circle.js","webpack://flatten-offset/./node_modules/flatten-js/classes/line.js","webpack://flatten-offset/./node_modules/flatten-js/classes/vector.js","webpack://flatten-offset/./node_modules/flatten-js/classes/point.js","webpack://flatten-offset/./node_modules/flatten-interval-tree/classes/interval.js","webpack://flatten-offset/./node_modules/flatten-interval-tree/classes/node.js","webpack://flatten-offset/./node_modules/flatten-js/data_structures/planar_set.js","webpack://flatten-offset/./node_modules/flatten-js/utils/errors.js","webpack://flatten-offset/./node_modules/flatten-js/utils/utils.js","webpack://flatten-offset/./node_modules/flatten-js/index.js","webpack://flatten-offset/./index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Node","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","nil_node","[object Object]","this","size","count","tree_walk","keys","res","node","push","item","output","isEmpty","undefined","insert_node","tree_insert","recalc_max","search_node","tree_search","delete_node","tree_delete","interval","resp_nodes","tree_search_interval","resp","forEach","visitor","node_current","parent","update_max","current_node","parent_node","less_than","left","right","insert_fixup","uncle_node","color","rotate_left","rotate_right","cut_node","fix_node","tree_successor","copy_data","delete_fixup","brother_node","equal_to","not_intersect_left_subtree","intersect","not_intersect_right_subtree","node_min","node_max","node_successor","local_minimum","x","y","action","height","heightLeft","heightRight","testBlackHeightProperty","Error","IntervalTree","Flatten","Polygon","Point","Segment","Arc","Circle","Line","Ray","Vector","vector","Distance","pt1","pt2","distanceTo","pt","line","closest_point","projectionOn","length","circle","dist2center","shortest_dist","center","Utils","EQ_0","toArc","start","dist","Math","abs","v","pc","normalize","multiply","translate","segment","equalTo","end","point2point","v_seg","v_ps2pt","v_pe2pt","start_sp","dot","end_sp","GE","v_unit","tangentInStart","cross","arc","shortest_segment","dist_and_segments","point2circle","on","sort","seg","ip","dist_and_segment","point2line","seg1","seg2","intersectSegment2Segment","point2segment","ps","pe","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","LT","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","dist_tmp","segment_tmp","point2arc","reverse","circle1","circle2","arc1","arc2","ip1","ip2","circle2circle","point","polygon","min_dist_and_segment","Number","POSITIVE_INFINITY","edge","edges","shape","polygon1","polygon2","edge1","edge2","box1","box2","mindist_x","max","xmin","xmax","mindist_y","ymin","ymax","mindist","box","merge","dx","dy","level","min_stop","tree","maxdist","box2box_minmax","Edge","insert","new_level_left","map","isNil","filter","new_level_right","new_level","LE","minmax_tree_process_level","set","index","squared_min_stop","min_dist_and_segment_new","stop","minmax_tree_calc_distance","sqrt","low","distance","PlanarSet","minmax_tree","d1","d2","GT","shape1","shape2","Face","Box","ray_shoot","faces","reduce","acc","face","vertices","args","add","delete","edgeFrom","edgeTo","next","remove","deleteFace","shapes","split","newEdge","edgeBefore","prev","clone","addFace","signedArea","rel","INSIDE","BOUNDARY","point2polygon","shape2polygon","shape2planarSet","valid","isSimple","vec","newPolygon","attrs","stroke","strokeWidth","fill","fillRule","fillOpacity","id","className","id_str","class_str","svgStr","svg","toJSON","contains","notIntersect","OUTSIDE","ray","norm","resp_edges","search","intersections","i1","i2","counter","intersection","prev_tangent","tangentInEnd","prev_point","cur_tangent","cur_point","prev_on_the_left","leftTo","cur_on_the_left","next_tangent","next_point","next_on_the_left","EQ","Errors","ILLEGAL_PARAMETERS","intersectRay2Segment","intersectRay2Arc","ip_tmp","first","last","_box","_orientation","Array","every","segments","points2segments","shapes2face","flattenShapes","flattenShape","startAngle","endAngle","counterClockwise","setArcLength","iterator","done","face_edges","points","append","arc_length","edgeAfter","edge_tmp","orientation","sArea","definiteIntegral","area","ORIENTATION","NOT_ORIENTABLE","CCW","CW","bv","bvStart","bvEnd","bvThisInOther","setInclusion","polyTmp","numInsideThis","CONTAINS","INTERLACE","getSelfIntersections","exitOnFirst","int_points","overlap","middle","bvMiddle","flag","OVERLAP_SAME","OVERLAP_OPPOSITE","largeArcFlag","sweepFlag","sweep","PI","sign","halfArc1","halfArc2","json","high","other_box","min","lessThan","width","PIx2","rotate","breakToFunctional","angle","slope","test_arc","cos","intersectArc2Circle","intersectArc2Arc","arc2circle","arc2line","segment2arc","arc2arc","func_arcs_array","angles","pts","test_arcs","new_arc","prev_arc","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","areaCircularSegment","circularSegmentArea","sin","coords","distanceToPoint","intersectSegment2Line","intersectSegment2Circle","intersectSegment2Arc","segment2circle","segment2line","segment2segment","rest","zero_segment","line1","line2","incidentTo","new_ip","ips","ips_tmp","counterclockwise","intersectCirle2Circle","circle2line","r1","r2","a","mid_pt","h","rotate90CCW","rotate90CW","a1","a2","points2norm","standard","other_line","invert","intersectLine2Line","intersectLine2Circle","intersectLine2Arc","intersectLine2Box","find","A1","B1","C1","A2","B2","C2","det","detX","detY","prj","v_trans","delta","segs","atan2","scalar","ZERO_DIVISION","rpoint","isNaN","x_rot","y_rot","proj_vec","Set","super","deleted","ReferenceError","DP_TOL","f","PI_2","CLIP_INSIDE","CLIP_OUTSIDE","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","NOT_VERTEX","START_VERTEX","END_VERTEX","BooleanOp","operands","res_poly","wrk_poly","op","booleanOpBinary","clip","wrk_poly_reversed","getIntersections","sortIntersections","splitByIntersections","int_points1_sorted","int_points2_sorted","filterDuplicatedIntersections","removeNotRelevantNotIntersectedFaces","int_points1","int_points2","initializeInclusionFlags","calculateInclusionFlags","setOverlappingFlags","removeNotRelevantChains","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","addToIntPoints","len","is_vertex","edge_before","edge_after","getSortedArray","faceMap","Map","has","faceId","slice","compareFn","int_point","addVertex","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","poly1","poly2","is_res_polygon","toBeDeleted","getRelation","cur_face","first_int_point_in_face","next_int_point1","num_int_points","cur_int_point1","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","setOverlap","int_point_current","int_point_next","first_int_point_in_face_num","next_int_point_num","int_points_from_pull_start","int_points_from_pull_num","intPointsPullCount","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","removeChain","k","cur_int_point_num","int_points_pull_num","res_polygon","wrk_polygon","int_point1","int_point2","other_int_points","int_point_tmp","isZeroLength","Interval","other_interval","not_intersect","val1","val2","other_node","value_equal","maximal_val","val_less_than","Offset","offsetEdge","w","offsetPolygon","offsetSegment","offsetArc","unify","subtract","v_seg_unit","v_left","v_right","seg_left","seg_right","cap1","arcSE","cap2","arc_cap1","arc_cap2","arc_outer","arcStartSweep","arcEndSweep","arc_inner","edge_cap1","edge_cap2","int_points_sorted","num","offset"],"mappings":"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","file":"flatten-offset.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flatten-offset\"] = factory();\n\telse\n\t\troot[\"flatten-offset\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 39);\n","/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n'use strict';\r\n\r\nlet Node = require('./classes/node');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('./utils/constants');\r\n\r\nlet nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree may store items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />\r\n * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,\r\n * see documentation {link}\r\n * @type {IntervalTree}\r\n */\r\nlet IntervalTree = class IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));\r\n        return res;\r\n    }\r\n\r\n    get isEmpty() {\r\n        return (this.root == null || this.root == nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param key - interval object or array of two numbers [low, high]\r\n     * @param value - value representing any object (optional)\r\n     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - value object to be checked\r\n     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - - value object\r\n     * @returns {boolean} - true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param interval - search interval, or array [low, high]\r\n     * @returns {Array}\r\n     */\r\n    search(interval) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        let resp = [];\r\n        resp_nodes.forEach((node) => {\r\n            if (node.item.value) {         // if there are values, return only values\r\n                resp.push(node.item.value);\r\n            }\r\n            else {                         // otherwise, return keys\r\n                resp.push(node.item.key.output());\r\n            }\r\n        }, []);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    };\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != nil_node) {\r\n            // if (node->left != nil_node && node->left->max >= low) {\r\n            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != nil_node && node->low <= high) {\r\n            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n};\r\n\r\nmodule.exports = IntervalTree;\r\n","/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    RB_TREE_COLOR_RED: 0,\r\n    RB_TREE_COLOR_BLACK: 1\r\n};","\"use strict\";\n\nlet IntervalTree = require('flatten-interval-tree');\n\nmodule.exports = function(Flatten) {\n    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;\n\n    let {vector} = Flatten;\n\n    Flatten.Distance = class Distance {\n        /**\n         * Calculate distance and shortest segment between points\n         * @param pt1\n         * @param pt2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2point(pt1, pt2) {\n            return pt1.distanceTo(pt2);\n        }\n\n        /**\n         * Calculate distance and shortest segment between point and line\n         * @param pt\n         * @param line\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2line(pt, line) {\n            let closest_point = pt.projectionOn(line);\n            let vec = vector(pt, closest_point);\n            return [vec.length, new Segment(pt, closest_point)];\n        }\n\n        /**\n         * Calculate distance and shortest segment between point and circle\n         * @param pt\n         * @param circle\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2circle(pt, circle) {\n            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n            if (Flatten.Utils.EQ_0(dist2center)) {\n                return [circle.r, new Segment(pt, circle.toArc().start)];\n            }\n            else {\n                let dist = Math.abs(dist2center - circle.r);\n                let v = vector(circle.pc, pt).normalize().multiply(circle.r);\n                let closest_point = circle.pc.translate(v);\n                return [dist, new Segment(pt, closest_point)];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between point and segment\n         * @param pt\n         * @param segment\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2segment(pt, segment) {\n            /* Degenerated case of zero-length segment */\n            if (segment.start.equalTo(segment.end)) {\n                return  Distance.point2point(pt, segment.start);\n            }\n\n            let v_seg = new Flatten.Vector(segment.start, segment.end);\n            let v_ps2pt = new Flatten.Vector(segment.start, pt);\n            let v_pe2pt = new Flatten.Vector(segment.end, pt);\n            let start_sp = v_seg.dot(v_ps2pt);\n            /* dot product v_seg * v_ps2pt */\n            let end_sp = -v_seg.dot(v_pe2pt);\n            /* minus dot product v_seg * v_pe2pt */\n\n            let dist;\n            let closest_point;\n            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\n                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n                /* unit vector ||v_unit|| = 1 */\n                dist = Math.abs(v_unit.cross(v_ps2pt));\n                /* dist = abs(v_unit x v_ps2pt) */\n                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n                return [dist, new Segment(pt, closest_point)];\n            }\n            else if (start_sp < 0) {                             /* point is out of scope closer to ps */\n                return pt.distanceTo(segment.start);\n            }\n            else {                                               /* point is out of scope closer to pe */\n                return pt.distanceTo(segment.end);\n            }\n        };\n\n        /**\n         * Calculate distance and shortest segment between point and arc\n         * @param pt\n         * @param arc\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2arc(pt, arc) {\n            let circle = new Flatten.Circle(arc.pc, arc.r);\n            let dist_and_segments = [];\n            let dist, shortest_segment;\n            [dist, shortest_segment] = Distance.point2circle(pt, circle);\n            if (shortest_segment.end.on(arc)) {\n                dist_and_segments.push(Distance.point2circle(pt, circle));\n            }\n            dist_and_segments.push( Distance.point2point(pt, arc.start) );\n            dist_and_segments.push( Distance.point2point(pt, arc.end) );\n\n            Distance.sort(dist_and_segments);\n\n            return dist_and_segments[0];\n        }\n\n        /**\n         * Calculate distance and shortest segment between segment and line\n         * @param seg\n         * @param line\n         * @returns {Number | Segment}\n         */\n        static segment2line(seg, line) {\n            let ip = seg.intersect(line);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\n            }\n\n            dist_and_segment.push(Distance.point2line(seg.start, line));\n            dist_and_segment.push(Distance.point2line(seg.end, line));\n\n            Distance.sort( dist_and_segment );\n            return dist_and_segment[0];\n\n        }\n\n        /**\n         * Calculate distance and shortest segment between two segments\n         * @param seg1\n         * @param seg2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static segment2segment(seg1, seg2) {\n            let ip = Segment.intersectSegment2Segment(seg1, seg2);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\n            }\n\n            // Seg1 and seg2 not intersected\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));\n            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));\n            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n\n            Distance.sort( dist_and_segment );\n            return dist_and_segment[0];\n        }\n\n        /**\n         * Calculate distance and shortest segment between segment and circle\n         * @param seg\n         * @param circle\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static segment2circle(seg, circle) {\n            /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n            let ip = seg.intersect(circle);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            // No intersection between segment and circle\n\n            /* Case 2. Distance to projection of center point to line bigger than radius\n             * And projection point belong to segment\n              * Then measure again distance from projection to circle and return it */\n            let line = new Flatten.Line(seg.ps, seg.pe);\n            let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n                return Distance.point2circle(shortest_segment.end, circle);\n            }\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\n            else {\n                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\n                    [dist_from_start, shortest_segment_from_start] :\n                    [dist_from_end, shortest_segment_from_end];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between segment and arc\n         * @param seg\n         * @param arc\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static segment2arc(seg, arc) {\n            /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n            let ip = seg.intersect(arc);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            // No intersection between segment and arc\n            let line = new Flatten.Line(seg.ps, seg.pe);\n            let circle = new Flatten.Circle(arc.pc, arc.r);\n\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\n             * projection point belongs to segment AND\n               * distance from projection point to circle belongs to arc  =>\n               * return this distance from projection to circle */\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n                let [dist_from_projection, shortest_segment_from_projection] =\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\n                if (shortest_segment_from_projection.end.on(arc)) {\n                    return [dist_from_projection, shortest_segment_from_projection];\n                }\n            }\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\n            let dist_and_segment = [];\n            dist_and_segment.push(Distance.point2arc(seg.start, arc));\n            dist_and_segment.push(Distance.point2arc(seg.end, arc));\n\n            let dist_tmp, segment_tmp;\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n\n        /**\n         * Calculate distance and shortest segment between two circles\n         * @param circle1\n         * @param circle2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static circle2circle(circle1, circle2) {\n            let ip = circle1.intersect(circle2);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n            if (circle1.center.equalTo(circle2.center)) {\n                let arc1 = circle1.toArc();\n                let arc2 = circle2.toArc();\n                return Distance.point2point(arc1.start, arc2.start);\n            }\n            else {\n                // Case 2. Not concentric circles\n                let line = new Line(circle1.center, circle2.center);\n                let ip1 = line.intersect(circle1);\n                let ip2 = line.intersect(circle2);\n\n                let dist_and_segment = [];\n\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n\n                Distance.sort(dist_and_segment);\n                return dist_and_segment[0];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between two circles\n         * @param circle\n         * @param line\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static circle2line(circle, line) {\n            let ip = circle.intersect(line);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        /**\n         * Calculate distance and shortest segment between arc and line\n         * @param arc\n         * @param line\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static arc2line(arc, line) {\n            /* Case 1 Line and arc intersected. Return the first point and zero distance */\n            let ip = line.intersect(arc);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let circle = new Flatten.Circle(arc.center, arc.r);\n\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\n             * projection point belongs to segment AND\n               * distance from projection point to circle belongs to arc  =>\n               * return this distance from projection to circle */\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n            if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n                let [dist_from_projection, shortest_segment_from_projection] =\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\n                if (shortest_segment_from_projection.end.on(arc)) {\n                    return [dist_from_projection, shortest_segment_from_projection];\n                }\n            }\n            else {\n                let dist_and_segment = [];\n                dist_and_segment.push( Distance.point2line(arc.start, line) );\n                dist_and_segment.push( Distance.point2line(arc.end, line) );\n\n                Distance.sort(dist_and_segment);\n                return dist_and_segment[0];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between arc and circle\n         * @param arc\n         * @param circle2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static arc2circle(arc, circle2) {\n            let ip = arc.intersect(circle2);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let circle1 = new Flatten.Circle(arc.center, arc.r);\n\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n            if (shortest_segment.start.on(arc)) {\n                return [dist, shortest_segment];\n            }\n            else {\n                let dist_and_segment = [];\n\n                dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n                dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n\n                Distance.sort(dist_and_segment);\n\n                return dist_and_segment[0];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between two arcs\n         * @param arc1\n         * @param arc2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static arc2arc(arc1, arc2) {\n            let ip = arc1.intersect(arc2);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n            let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n                return [dist, shortest_segment];\n            }\n            else {\n                let dist_and_segment = [];\n\n                let dist_tmp, segment_tmp;\n\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n                if (segment_tmp.end.on(arc2)) {\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\n                }\n\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n                if (segment_tmp.end.on(arc2)) {\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\n                }\n\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n                if (segment_tmp.end.on(arc1)) {\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n                }\n\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n                if (segment_tmp.end.on(arc1)) {\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n                }\n\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n\n                Distance.sort(dist_and_segment);\n\n                return dist_and_segment[0];\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment between point and polygon\n         * @param point\n         * @param polygon\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static point2polygon(point, polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\n            for (let edge of polygon.edges) {\n                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?\n                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n\n        static shape2polygon(shape, polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\n            for (let edge of polygon.edges) {\n                let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n\n/*\n        static arc2polygon(arc, polygon) {\n            let ip = arc.intersect(polygon);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\n            for (let edge of polygon.edges) {\n                let [dist, shortest_segment] = arc.distanceTo(edge.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n\n        static line2polygon(line, polygon) {\n            let ip = line.intersect(polygon);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\n            for (let edge of polygon.edges) {\n                let [dist, shortest_segment] = line.distanceTo(edge.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n\n        static circle2polygon(circle, polygon) {\n            let ip = circle.intersect(polygon);\n            if (ip.length > 0) {\n                return [0, new Segment(ip[0], ip[0])];\n            }\n\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\n            for (let edge of polygon.edges) {\n                let [dist, shortest_segment] = circle.distanceTo(edge.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n*/\n\n        /**\n         * Calculate distance and shortest segment between two polygons\n         * @param polygon1\n         * @param polygon2\n         * @returns {Number | Segment} - distance and shortest segment\n         */\n        static polygon2polygon(polygon1, polygon2) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n            for (let edge1 of polygon1.edges) {\n                for (let edge2 of polygon2.edges) {\n                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                        min_dist_and_segment = [dist, shortest_segment];\n                    }\n                }\n            }\n            return min_dist_and_segment;\n        }\n\n        /**\n         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n         * Minimal distance by x is\n         *    (box2.xmin - box1.xmax), if box1 is left to box2\n         *    (box1.xmin - box2.xmax), if box2 is left to box1\n         *    0,                       if box1 and box2 are intersected by x\n         * Minimal distance by y is defined in the same way\n         *\n         * Maximal distance is estimated as a sum of squared dimensions of the merged box\n         *\n         * @param box1\n         * @param box2\n         * @returns {Number | Number} - minimal and maximal distance\n         */\n        static box2box_minmax(box1, box2) {\n            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );\n            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );\n            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;\n\n            let box = box1.merge(box2);\n            let dx = box.xmax - box.xmin;\n            let dy = box.ymax - box.ymin;\n            let maxdist = dx*dx + dy*dy;\n\n            return [mindist, maxdist];\n        }\n\n        static minmax_tree_process_level(shape, level, min_stop, tree) {\n            // Calculate minmax distance to each shape in current level\n            // Insert result into the interval tree for further processing\n            // update min_stop with maxdist, it will be the new stop distance\n            let mindist, maxdist;\n            for (let node of level) {\n\n                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n                // if (Flatten.Utils.GT(mindist, min_stop))\n                //     continue;\n\n                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n                if (node.item.value instanceof Flatten.Edge) {\n                    tree.insert([mindist, maxdist], node.item.value.shape);\n                }\n                else {\n                    tree.insert([mindist, maxdist], node.item.value);\n                }\n                if (Flatten.Utils.LT(maxdist, min_stop)) {\n                    min_stop = maxdist;                       // this will be the new distance estimation\n                }\n            }\n\n            if (level.length === 0)\n                return min_stop;\n\n            // Calculate new level from left and right children of the current\n            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);\n            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n            // Merge left and right subtrees and leave only relevant subtrees\n            let new_level = [...new_level_left, ...new_level_right].filter( node => {\n                // Node subtree quick reject, node.max is a subtree box\n                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n                return (Flatten.Utils.LE(mindist, min_stop));\n            });\n\n            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n            return min_stop;\n        }\n\n        /**\n         * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n         * and shapes of the planar set.\n         * @param shape\n         * @param set\n         */\n        static minmax_tree(shape, set, min_stop) {\n            let tree = new IntervalTree();\n            let level = [set.index.root];\n            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;\n            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n            return tree;\n        }\n\n        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n            let min_dist_and_segment_new, stop;\n            if (node != null && !node.isNil()) {\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n\n                if (stop) {\n                    return [min_dist_and_segment_new, stop];\n                }\n\n                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n                    return [min_dist_and_segment_new, true];   // stop condition\n                }\n\n                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n                // console.log(dist)\n                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n                    min_dist_and_segment_new = [dist, shortest_segment];\n                }\n\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n\n                return [min_dist_and_segment_new, stop];\n            }\n\n            return [min_dist_and_segment, false];\n        }\n\n        /**\n         * Calculates distance between shape and Planar Set of shapes\n         * @param shape\n         * @param {PlanarSet} set\n         * @param {Number} min_stop\n         * @returns {*}\n         */\n        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n            let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n            let stop = false;\n            if (set instanceof Flatten.PlanarSet) {\n                let tree = Distance.minmax_tree(shape, set, min_stop);\n                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n            }\n            return min_dist_and_segment;\n        }\n\n        static sort(dist_and_segment) {\n            dist_and_segment.sort((d1, d2) => {\n                if (Flatten.Utils.LT(d1[0], d2[0])) {\n                    return -1;\n                }\n                if (Flatten.Utils.GT(d1[0], d2[0])) {\n                    return 1;\n                }\n                return 0;\n            });\n        }\n\n        static distance(shape1, shape2) {\n            return shape1.distanceTo(shape2);\n        }\n    }\n};","/**\n * Created by Alex Bol on 3/15/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    let {Edge, Face, PlanarSet, Box} = Flatten;\n    let {ray_shoot} = Flatten;\n    /**\n     * Class representing a polygon.<br/>\n     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n     * @type {Polygon}\n     */\n    Flatten.Polygon = class Polygon {\n        /**\n         * Constructor creates new instance of polygon.<br/>\n         * New polygon is empty. Add face to the polygon using method <br/>\n         * <code>\n         *     polygon.addFace(Points[]|Segments[]|Arcs[])\n         * </code>\n         */\n        constructor() {\n            /**\n             * Container of faces (closed loops), may be empty\n             * @type {PlanarSet}\n             */\n            this.faces = new PlanarSet();\n            /**\n             * Container of edges\n             * @type {PlanarSet}\n             */\n            this.edges = new PlanarSet();\n        }\n\n        /**\n         * (Getter) Returns bounding box of the polygon\n         * @returns {Box}\n         */\n        get box() {\n            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );\n        }\n\n        /**\n         * (Getter) Returns array of vertices\n         * @returns {Array}\n         */\n        get vertices() {\n            return [...this.edges].map( edge => edge.start);\n        }\n\n        /**\n         * Add new face to polygon. Returns added face\n         * @param {Points[]|Segments[]|Arcs[]} args - list of points or list of shapes (segments and arcs)\n         * which comprise a closed loop\n         * @returns {Face}\n         */\n        addFace(...args) {\n            let face = new Face(this, ...args);\n            this.faces.add(face);\n            return face;\n        }\n\n        /**\n         * Delete existing face from polygon\n         * @param {Face} face Face to be deleted\n         * @returns {boolean}\n         */\n        deleteFace(face) {\n            for (let edge of face) {\n                let deleted = this.edges.delete(edge);\n            }\n            let deleted = this.faces.delete(face);\n            return deleted;\n        }\n\n        /**\n         * Delete chain of edges from the face.\n         * @param {Face} face Face to remove chain\n         * @param {Edge} edgeFrom Start of the chain of edges to be removed\n         * @param {Edge} edgeTo End of the chain of edges to be removed\n         */\n        removeChain(face, edgeFrom, edgeTo) {\n            // Special case: all edges removed\n            if (edgeTo.next === edgeFrom) {\n                this.deleteFace(face);\n                return;\n            }\n            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {\n                face.remove(this.edges, edge);\n                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index\n                if (face.isEmpty()) {\n                    this.deleteFace(face);    // delete from PlanarSet of faces and update index\n                    break;\n                }\n            }\n        }\n\n        /**\n         * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n         * When edge is split, new edge created from the start of the edge to the new vertex\n         * and inserted before current edge.\n         * Current edge is trimmed and updated. Method returns new edge added.\n         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n         * @param {Point} pt Point to be added as a new vertex\n         * @returns {Edge}\n         */\n        addVertex(pt, edge) {\n            let shapes = edge.shape.split(pt);\n            if (shapes.length < 2) return;\n            let newEdge = new Flatten.Edge(shapes[0]);\n            let edgeBefore = edge.prev;\n\n            /* Insert first split edge into linked list after edgeBefore */\n            edge.face.insert(this.edges, newEdge, edgeBefore);\n\n            // Remove old edge from edges container and 2d index\n            this.edges.delete(edge);\n\n            // Update edge shape with second split edge keeping links\n            edge.shape = shapes[1];\n\n            // Add updated edge to the edges container and 2d index\n            this.edges.add(edge);\n\n            return newEdge;\n        }\n\n        reverse() {\n            for (let face of this.faces) {\n                face.reverse();\n            }\n            return this;\n        }\n\n        /**\n         * Create new copied instance of the polygon\n         * @returns {Polygon}\n         */\n        clone() {\n            let polygon = new Polygon();\n            for (let face of this.faces) {\n                let shapes = [];\n                for (let edge of face) {\n                    shapes.push(edge.shape.clone());\n                }\n                polygon.addFace(shapes);\n            }\n            return polygon;\n        }\n\n        /**\n         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n         * @returns {number}\n         */\n        area() {\n            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);\n            return Math.abs(signedArea);\n        }\n\n        /**\n         * Returns true if polygon contains point, including polygon boundary, false otherwise\n         * Point in polygon test based on ray shooting algorithm\n         * @param {Point} point - test point\n         * @returns {boolean}\n         */\n        contains(point) {\n            let rel = ray_shoot(this, point);\n            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;\n        }\n\n        /**\n         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n         * @returns {Number | Segment}\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n\n            if (shape instanceof Flatten.Point) {\n                let [dist, shortest_segment] = Distance.point2polygon(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Circle ||\n            shape instanceof Flatten.Line ||\n            shape instanceof Flatten.Segment ||\n            shape instanceof Flatten.Arc) {\n                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [dist, shortest_segment];\n            }\n\n            /* this method is bit faster */\n            if (shape instanceof  Flatten.Polygon) {\n                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n                let dist, shortest_segment;\n\n                for (let edge of this.edges) {\n                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                    let min_stop = min_dist_and_segment[0];\n                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                    if (Flatten.Utils.LT(dist, min_stop)) {\n                        min_dist_and_segment = [dist, shortest_segment];\n                    }\n                }\n                return min_dist_and_segment;\n            }\n        }\n\n        /**\n         * Return true if polygon is valid for boolean operations\n         * Polygon is valid if <br/>\n         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n         * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n         * @returns {boolean}\n         */\n        isValid() {\n            let valid = true;\n            // 1. Polygon is invalid if at least one face is not simple\n            for (let face of this.faces) {\n                if (!face.isSimple(this.edges)) {\n                    valid = false;\n                    break;\n                }\n            }\n            // 2. TODO: check if no island inside island and no hole inside hole\n            // 3. TODO: check the there is no intersection between faces\n            return valid;\n        }\n\n        /**\n         * Returns new polygon translated by vector vec\n         * @param {Vector} vec\n         * @returns {Polygon}\n         */\n        translate(vec) {\n            let newPolygon = new Polygon();\n            for (let face of this.faces) {\n                let shapes = [];\n                for (let edge of face) {\n                    shapes.push(edge.shape.translate(vec));\n                }\n                newPolygon.addFace(shapes);\n            }\n            return newPolygon;\n        }\n\n        /**\n         * Return string to draw polygon in svg\n         * @param attrs  - json structure with attributes for svg path element,\n         * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\"\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\"\n         * @returns {string}\n         */\n        svg(attrs = {}) {\n            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\n            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n            let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\n            for (let face of this.faces) {\n                svgStr += face.svg();\n            }\n            svgStr += `\" >\\n</path>`;\n\n            return svgStr;\n        }\n\n        toJSON() {\n            return [...this.faces].map(face => face.toJSON());\n        }\n    }\n};","\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;\n\n    Flatten.ray_shoot = function(polygon, point) {\n        let contains = undefined;\n\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        // }\n\n        // 1. Quick reject\n        if (polygon.box.notIntersect(point.box)) {\n            return Flatten.OUTSIDE;\n        }\n\n        let ray = new Ray(point);\n        let line = new Line(ray.pt, ray.norm);\n\n        // 2. Locate relevant edges of the polygon\n        let resp_edges = polygon.edges.search(ray.box);\n\n        if (resp_edges.length == 0) {\n            return Flatten.OUTSIDE;\n        }\n\n        // 3. Calculate intersections\n        let intersections = [];\n        for (let edge of resp_edges) {\n            for (let ip of ray.intersect(edge.shape)) {\n\n                // If intersection is equal to query point then point lays on boundary\n                if (ip.equalTo(point)) {\n                    return Flatten.BOUNDARY;\n                }\n\n                intersections.push({\n                    pt: ip,\n                    edge: edge\n                });\n            }\n        }\n\n        // 4. Sort intersection in x-ascending order\n        intersections.sort( (i1, i2) => {\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // 5. Count real intersections, exclude touching\n        let counter = 0;\n\n        for (let i=0; i < intersections.length; i++) {\n            let intersection = intersections[i];\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n                /* skip same point between same edges if already counted */\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\n                    intersection.edge.prev === intersections[i-1].edge) {\n                    continue;\n                }\n                let prev_edge = intersection.edge.prev;\n                let prev_tangent = prev_edge.shape.tangentInEnd();\n                let prev_point = intersection.pt.translate(prev_tangent);\n\n                let cur_tangent = intersection.edge.shape.tangentInStart();\n                let cur_point = intersection.pt.translate(cur_tangent);\n\n                let prev_on_the_left = prev_point.leftTo(line);\n                let cur_on_the_left = cur_point.leftTo(line);\n\n                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {\n                    counter++;\n                }\n            }\n            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n                /* skip same point between same edges if already counted */\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\n                    intersection.edge.next === intersections[i-1].edge) {\n                    continue;\n                }\n                let next_edge = intersection.edge.next;\n                let next_tangent = next_edge.shape.tangentInStart();\n                let next_point = intersection.pt.translate(next_tangent);\n\n                let cur_tangent = intersection.edge.shape.tangentInEnd();\n                let cur_point = intersection.pt.translate(cur_tangent);\n\n                let next_on_the_left = next_point.leftTo(line);\n                let cur_on_the_left = cur_point.leftTo(line);\n\n                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {\n                    counter++;\n                }\n            }\n            else {        /* intersection point is not a coincident with a vertex */\n                if (intersection.edge.shape instanceof Segment) {\n                    counter++;\n                }\n                else {\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                    let box = intersection.edge.shape.box;\n                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||\n                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {\n                        counter++;\n                    }\n                }\n            }\n        }\n\n        // 6. Odd or even?\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\n\n        return contains;\n    };\n};","\"use strict\";\n\nmodule.exports = function(Flatten) {\n    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;\n    /**\n     * Class representing a horizontal ray, used by ray shooting algorithm\n     * @type {Ray}\n     */\n    Flatten.Ray = class Ray {\n        /**\n         * Construct ray by setting start point\n         * @param {Point} pt - start point\n         */\n        constructor(...args) {\n            this.pt = new Point();\n\n            if (args.length == 0) {\n                return;\n            }\n\n            if (args.length == 1 && args[0] instanceof Point) {\n                this.pt = args[0].clone();\n                return;\n            }\n\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\n                this.pt = new Point(args[0], args[1]);\n                return;\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\n         * Returns copied instance of the ray object\n         * @returns {Ray}\n         */\n        clone() {\n            return new Ray(this.pt);\n        }\n\n        /**\n         * Returns half-infinite bounding box of the ray\n         * @returns {Box} - bounding box\n         */\n        get box() {\n            return new Box(\n                this.pt.x,\n                this.pt.y,\n                Number.POSITIVE_INFINITY,\n                this.pt.y\n            )\n        }\n\n        /**\n         * Return ray start point\n         * @returns {Point} - ray start point\n         */\n        get start() {\n            return this.pt;\n        }\n\n        /**\n         * Return ray normal vector (0,1) - horizontal ray\n         * @returns {Vector} - ray normal vector\n         */\n        get norm() {\n            return new Vector(0,1);\n        }\n\n        /**\n         * Returns array of intersection points between ray and segment or arc\n         * @param {Segment|Arc} - Shape to intersect with ray\n         * @returns {Array} array of intersection points\n         */\n        intersect(shape) {\n            if (shape instanceof Segment) {\n                return this.intersectRay2Segment(this, shape);\n            }\n\n            if (shape instanceof Arc) {\n                return this.intersectRay2Arc(this, shape);\n            }\n        }\n\n        intersectRay2Segment(ray, segment) {\n            let ip = [];\n\n            if (ray.box.notIntersect(segment.box)) {\n                return ip;\n            }\n\n            let line = new Line(ray.start, ray.norm);\n            let ip_tmp = line.intersect(segment);\n\n            for (let pt of ip_tmp) {\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n                    ip.push(pt);\n                }\n            }\n\n            /* If there were two intersection points between line and ray,\n            and now there is exactly one left, it means ray starts between these points\n            and there is another intersection point - start of the ray */\n            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\n                ip.push(ray.start);\n            }\n\n            return ip;\n        }\n\n        intersectRay2Arc(ray, arc) {\n            let ip = [];\n\n            if (ray.box.notIntersect(arc.box)) {\n                return ip;\n            }\n\n            let line = new Line(ray.start, ray.norm);\n            let ip_tmp = line.intersect(arc);\n\n            for (let pt of ip_tmp) {\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\n                    ip.push(pt);\n                }\n            }\n            return ip;\n        }\n    };\n\n    Flatten.ray = (...args) => new Flatten.Ray(...args);\n};","/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function (Flatten) {\n    let {Point, Segment, Arc, Box, Edge} = Flatten;\n    /**\n     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n     * Face object cannot be instantiated with a constructor.\n     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n     * <br/>\n     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n     * Container of edges is a property of the polygon object. <br/>\n     *\n     * @example\n     * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n     * for (let edge of face) {\n     *      console.log(edge.shape.length)     // do something\n     * }\n     *\n     * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n     * let edge = face.first;\n     * do {\n     *   console.log(edge.shape.length);   // do something\n     *   edge = edge.next;\n     * } while (edge != face.first)\n     */\n    Flatten.Face = class Face {\n        constructor(polygon, ...args) {\n            /**\n             * Reference to the first edge in face\n             */\n            this.first;\n            /**\n             * Reference to the last edge in face\n             */\n            this.last;\n\n            this._box = undefined;  // new Box();\n            this._orientation = undefined;\n\n            if (args.length == 0) {\n                return;\n            }\n\n            /* If passed an array it supposed to be:\n             1) array of shapes that performs close loop or\n             2) array of points that performs set of vertices\n             */\n            if (args.length == 1) {\n                if (args[0] instanceof Array) {\n                    // let argsArray = args[0];\n                    let shapes = args[0];  // argsArray[0];\n                    if (shapes.length == 0)\n                        return;\n\n                    if (shapes.every((shape) => {\n                            return shape instanceof Point\n                        })) {\n                        let segments = Face.points2segments(shapes);\n                        this.shapes2face(polygon.edges, segments);\n                    }\n                    else if (shapes.every((shape) => {\n                            return (shape instanceof Segment || shape instanceof Arc)\n                        })) {\n                        this.shapes2face(polygon.edges, shapes);\n                    }\n                    // this is from JSON.parse object\n                    else if (shapes.every((shape) => {\n                            return (shape.name === \"segment\" || shape.name === \"arc\")\n                        })) {\n                        let flattenShapes = [];\n                        for (let shape of shapes) {\n                            let flattenShape;\n                            if (shape.name === \"segment\") {\n                                flattenShape = new Segment(shape.ps.x, shape.ps.y, shape.pe.x, shape.pe.y);\n                            }\n                            else {\n                                flattenShape = new Arc(new Point(shape.pc.x, shape.pc.y),\n                                    shape.r, shape.startAngle, shape.endAngle, shape.counterClockwise);\n                            }\n                            flattenShapes.push(flattenShape);\n                        }\n                        this.shapes2face(polygon.edges, flattenShapes);\n                    }\n                }\n                /* Create new face and copy edges into polygon.edges set */\n                else if (args[0] instanceof Face) {\n                    let face = args[0];\n                    this.first = face.first;\n                    this.last = face.last;\n                    for (let edge of face) {\n                        polygon.edges.add(edge);\n                    }\n                }\n            }\n            /* If passed two edges, consider them as start and end of the face loop */\n            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {\n                this.first = args[0];                          // first edge in face or undefined\n                this.last = args[1];                           // last edge in face or undefined\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n                // set arc length\n                this.setArcLength();\n                /*\n                 let edge = this.first;\n                 edge.arc_length = 0;\n                 edge = edge.next;\n                 while (edge !== this.first) {\n                 edge.arc_length = edge.prev.arc_length + edge.prev.length;\n                 edge = edge.next;\n                 }\n                 */\n\n                // this.box = this.getBox();\n                // this.orientation = this.getOrientation();      // face direction cw or ccw\n            }\n        }\n\n        [Symbol.iterator]() {\n            let edge = undefined;\n            return {\n                next: () => {\n                    let value = edge ? edge : this.first;\n                    let done = this.first ? (edge ? edge === this.first : false) : true;\n                    edge = value ? value.next : undefined;\n                    return {value: value, done: done};\n                }\n            };\n        };\n\n        /**\n         * Return array of edges from first to last\n         * @returns {Array}\n         */\n        get edges() {\n            let face_edges = [];\n            for (let edge of this) {\n                face_edges.push(edge);\n            }\n            return face_edges;\n        }\n\n        /**\n         * Return number of edges in the face\n         * @returns {number}\n         */\n        get size() {\n            let counter = 0;\n            for (let edge of this) {\n                counter++;\n            }\n            return counter;\n        }\n\n        static points2segments(points) {\n            let segments = [];\n            for (let i = 0; i < points.length; i++) {\n                segments.push(new Segment(points[i], points[(i + 1) % points.length]));\n            }\n            return segments;\n        }\n\n        shapes2face(edges, shapes) {\n            for (let shape of shapes) {\n                let edge = new Edge(shape);\n                this.append(edges, edge);\n                // this.box = this.box.merge(shape.box);\n                // edges.add(edge);\n            }\n            // this.orientation = this.getOrientation();              // face direction cw or ccw\n        }\n\n        /**\n         * Returns true if face is empty, false otherwise\n         * @returns {boolean}\n         */\n        isEmpty() {\n            return (this.first === undefined && this.last === undefined)\n        }\n\n        /**\n         * Append given edge after the last edge (and before the first edge). <br/>\n         * This method mutates current object and does not return any value\n         * @param {PlanarSet} edges - Container of edges\n         * @param {Edge} edge - Edge to be appended to the linked list\n         */\n        append(edges, edge) {\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n                edge.arc_length = 0;\n            }\n            else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n\n                // update edge to be last\n                this.last = edge;\n\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n                // set arc length\n                edge.arc_length = edge.prev.arc_length + edge.prev.length;\n            }\n            edge.face = this;\n\n            edges.add(edge);      // Add new edges into edges container\n        }\n\n        /**\n         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n         * This method mutates current object and does not return any value\n         * @param {PlanarSet} edges - Container of edges\n         * @param {Edge} newEdge - Edge to be inserted into linked list\n         * @param {Edge} edgeBefore - Edge to insert newEdge after it\n         */\n        insert(edges, newEdge, edgeBefore) {\n            if (this.first === undefined) {\n                edge.prev = newEdge;\n                edge.next = newEdge;\n                this.first = newEdge;\n                this.last = newEdge;\n            }\n            else {\n                /* set links to new edge */\n                let edgeAfter = edgeBefore.next;\n                edgeBefore.next = newEdge;\n                edgeAfter.prev = newEdge;\n\n                /* set links from new edge */\n                newEdge.prev = edgeBefore;\n                newEdge.next = edgeAfter;\n\n                /* extend chain if new edge added after last edge */\n                if (this.last === edgeBefore)\n                    this.first = newEdge;\n            }\n            newEdge.face = this;\n\n            edges.add(newEdge);      // Add new edges into edges container\n        }\n\n        /**\n         * Remove the given edge from the linked list of the face <br/>\n         * This method mutates current object and does not return any value\n         * @param {PlanarSet} edges - Container of edges\n         * @param {Edge} edge - Edge to be removed\n         */\n        remove(edges, edge) {\n            // special case if last edge removed\n            if (edge === this.first && edge === this.last) {\n                this.first = undefined;\n                this.last = undefined;\n            }\n            else {\n                // update linked list\n                edge.prev.next = edge.next;\n                edge.next.prev = edge.prev;\n                // update first if need\n                if (edge === this.first) {\n                    this.first = edge.next;\n                }\n                // update last if need\n                if (edge === this.last) {\n                    this.last = edge.prev;\n                }\n            }\n            edges.delete(edge);      // delete from PlanarSet of edges and update index\n        }\n\n        /**\n         * Reverse orientation of the face: first edge become last and vice a verse,\n         * all edges starts and ends swapped, direction of arcs inverted.\n         */\n        reverse() {\n            // collect edges in revert order with reverted shapes\n            let edges = [];\n            let edge_tmp = this.last;\n            do {\n                // reverse shape\n                edge_tmp.shape = edge_tmp.shape.reverse();\n                edges.push(edge_tmp);\n                edge_tmp = edge_tmp.prev;\n            } while (edge_tmp !== this.last);\n\n            // restore linked list\n            this.first = undefined;\n            this.last = undefined;\n            for (let edge of edges) {\n                if (this.first === undefined) {\n                    edge.prev = edge;\n                    edge.next = edge;\n                    this.first = edge;\n                    this.last = edge;\n                    edge.arc_length = 0;\n                }\n                else {\n                    // append to end\n                    edge.prev = this.last;\n                    this.last.next = edge;\n\n                    // update edge to be last\n                    this.last = edge;\n\n                    // restore circular links\n                    this.last.next = this.first;\n                    this.first.prev = this.last;\n\n                    // set arc length\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\n                }\n            }\n\n            // Recalculate orientation, if set\n            if (this._orientation !== undefined) {\n                this._orientation = undefined;\n                this._orientation = this.orientation();\n            }\n        }\n\n\n        /**\n         * Set arc_length property for each of the edges in the face.\n         * Arc_length of the edge it the arc length from the first edge of the face\n         */\n        setArcLength() {\n            for (let edge of this) {\n                if (edge === this.first) {\n                    edge.arc_length = 0.0;\n                }\n                else {\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\n                }\n                edge.face = this;\n            }\n        }\n\n        /**\n         * Returns the absolute value of the area of the face\n         * @returns {number}\n         */\n        area() {\n            return Math.abs(this.signedArea());\n        }\n\n        /**\n         * Returns signed area of the simple face.\n         * Face is simple if it has no self intersections that change its orientation.\n         * Then the area will be positive if the orientation of the face is clockwise,\n         * and negative if orientation is counterclockwise.\n         * It may be zero if polygon is degenerated.\n         * @returns {number}\n         */\n        signedArea() {\n            let sArea = 0;\n            for (let edge of this) {\n                sArea += edge.shape.definiteIntegral(this.box.ymin);\n            }\n            return sArea;\n        }\n\n        /**\n         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n         * According to Green theorem the area of a closed curve may be calculated as double integral,\n         * and the sign of the integral will be defined by the direction of the curve.\n         * When the integral (\"signed area\") will be negative, direction is counter clockwise,\n         * when positive - clockwise and when it is zero, polygon is not orientable.\n         * See {@link https://mathinsight.org/greens_theorem_find_area}\n         * @returns {number}\n         */\n        orientation() {\n            if (this._orientation === undefined) {\n                let area = this.signedArea();\n                if (Flatten.Utils.EQ_0(area)) {\n                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\n                }\n                else if (Flatten.Utils.LT(area, 0)) {\n                    this._orientation = Flatten.ORIENTATION.CCW;\n                }\n                else {\n                    this._orientation = Flatten.ORIENTATION.CW;\n                }\n            }\n            return this._orientation;\n        }\n\n        /**\n         * Return bounding box of the face\n         * @returns {Box}\n         */\n        get box() {\n            if (this._box === undefined) {\n                let box = new Flatten.Box();\n                for (let edge of this) {\n                    box = box.merge(edge.box);\n                }\n                this._box = box;\n            }\n            return this._box;\n        }\n\n        /**\n         * Check relation between face and other polygon\n         * on strong assumption that they are NOT INTERSECTED <br/>\n         * Then there are 4 options: <br/>\n         * face disjoint to polygon - Flatten.OUTSIDE <br/>\n         * face inside polygon - Flatten.INSIDE <br/>\n         * face contains polygon - Flatten.CONTAIN <br/>\n         * face interlaced with polygon: inside some face and contains other face - Flatten.INTERLACE <br/>\n         * @param {Polygon} polygon - Polygon to check relation\n         */\n        getRelation(polygon) {\n            this.first.bv = this.first.bvStart = this.first.bvEnd = undefined;\n            let bvThisInOther = this.first.setInclusion(polygon);\n            let resp = polygon.faces.search(this.box);\n            if (resp.length === 0) {\n                return bvThisInOther;        // OUTSIDE or INSIDE\n            }\n            else {                           // possible INTERLACE\n                let polyTmp = new Flatten.Polygon();\n                polyTmp.addFace(this);\n\n                let numInsideThis = 0;\n                for (let face of resp) {\n                    face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n                    let bvOtherInThis = face.first.setInclusion(polyTmp);\n                    if (bvOtherInThis === Flatten.INSIDE) {\n                        numInsideThis++;\n                    }\n                }\n                if (bvThisInOther === Flatten.OUTSIDE) {\n                    if (numInsideThis === 0) {                   // none inside this - outside\n                        return Flatten.OUTSIDE;\n                    }\n                    else if (numInsideThis === resp.length) {      // all from resp inside this - contains or interlace\n                        if (resp.length === polygon.faces.size) {\n                            return Flatten.CONTAINS;               // all faces from polygon are in response - contains\n                        }\n                        else {\n                            return Flatten.INTERLACE;              // some faces inside - interlace\n                        }\n                    }\n                    else {\n                        return Flatten.INTERLACE;                  // some faces inside - interlace\n                    }\n                }\n                else if (bvThisInOther === Flatten.INSIDE) {\n                    return numInsideThis === 0 ? Flatten.INSIDE : Flatten.INTERLACE;\n                }\n            }\n        }\n\n        /**\n         * Returns true if face of the polygon is simple (no self-intersection points found)\n         * NOTE: this method is incomplete because it doe not exclude touching points\n         * Real self intersection inverts orientation of the polygon.\n         * But this is also good enough for the demonstration of the idea\n         * @param {Edges} edges - reference to polygon.edges to provide search index\n         * @returns {boolean}\n         */\n        isSimple(edges) {\n            let ip = Face.getSelfIntersections(this, edges, true);\n            return ip.length == 0;\n        }\n\n        static getSelfIntersections(face, edges, exitOnFirst = false) {\n            let int_points = [];\n\n            // calculate intersections\n            for (let edge1 of face) {\n\n                // request edges of polygon in the box of edge1\n                let resp = edges.search(edge1.box);\n\n                // for each edge2 in response\n                for (let edge2 of resp) {\n\n                    // Skip itself\n                    if (edge1 === edge2)\n                        continue;\n\n                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\n                        (edge1.next === edge2 || edge1.prev === edge2))\n                        continue;\n\n                    // calculate intersections between edge1 and edge2\n                    let ip = edge1.shape.intersect(edge2.shape);\n\n                    // for each intersection point\n                    for (let pt of ip) {\n\n                        // skip start-end connections\n                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\n                            continue;\n                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\n                            continue;\n\n                        int_points.push(pt);\n\n                        if (exitOnFirst)\n                            break;\n                    }\n\n                    if (int_points.length > 0 && exitOnFirst)\n                        break;\n                }\n\n                if (int_points.length > 0 && exitOnFirst)\n                    break;\n\n            }\n            return int_points;\n        }\n\n        toJSON() {\n            return this.edges.map(edge => edge.toJSON());\n        }\n\n        svg() {\n            let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\n\n            for (let edge of this) {\n                svgStr += edge.svg();\n            }\n\n            svgStr += ` z`;\n            return svgStr;\n        }\n\n    };\n};","/**\n * Created by Alex Bol on 3/17/2017.\n */\n\nmodule.exports = function(Flatten) {\n    /**\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n     * Each edge contains references to the next and previous edges in the face of the polygon.\n     *\n     * @type {Edge}\n     */\n    Flatten.Edge = class Edge {\n        /**\n         * Construct new instance of edge\n         * @param {Shape} shape Shape of type Segment of Arc\n         */\n        constructor(shape) {\n            /**\n             * Shape of the edge: Segment or Arc\n             */\n            this.shape = shape;\n            /**\n             * Pointer to the next edge in the face\n             */\n            this.next;\n            /**\n             * Pointer to the previous edge in the face\n             */\n            this.prev;\n            /**\n             * Pointer to the face containing this edge\n             * @type {Face}\n             */\n            this.face;\n            /**\n             * \"Arc distance\" from the face start\n             * @type {number}\n             */\n            this.arc_length = 0;\n            /**\n             * Start inclusion flag (inside/outside/boundary)\n             * @type {Boolean}\n             */\n            this.bvStart = undefined;\n            /**\n             * End inclusion flag (inside/outside/boundary)\n             * @type {Boolean}\n             */\n            this.bvEnd = undefined;\n            /**\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n             * @type {*}\n             */\n            this.bv = undefined;\n            /**\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n             * @type {*}\n             */\n            this.overlap = undefined;\n        }\n\n        /**\n         * Get edge start point\n         */\n        get start() {\n            return this.shape.start;\n        }\n\n        /**\n         * Get edge end point\n         */\n        get end() {\n            return this.shape.end;\n        }\n\n        /**\n         * Get edge length\n         */\n        get length() {\n            return this.shape.length;\n        }\n\n        /**\n         * Get bounding box of the edge\n         * @returns {Box}\n         */\n        get box() {\n            return this.shape.box;\n        }\n\n        /**\n         * Get middle point of the edge\n         * @returns {Point}\n         */\n        middle() {\n            return this.shape.middle();\n        }\n\n        /**\n         * Returns true if point belongs to the edge, false otherwise\n         * @param {Point} pt - test point\n         */\n        contains(pt) {\n            return this.shape.contains(pt);\n        }\n\n        /**\n         * Set inclusion flag of the edge with respect to another polygon\n         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n         * @param polygon\n         */\n        setInclusion(polygon) {\n            if (this.bv !== undefined) return this.bv;\n\n            if (this.bvStart === undefined) {\n                this.bvStart = Flatten.ray_shoot(polygon, this.start);\n            }\n            if (this.bvEnd === undefined) {\n                this.bvEnd = Flatten.ray_shoot(polygon, this.end);\n            }\n            /* At least one end outside - the whole edge outside */\n            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n                this.bv = Flatten.OUTSIDE;\n            }\n            /* At least one end inside - the whole edge inside */\n            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n                this.bv = Flatten.INSIDE;\n            }\n            /* Both are boundary - check the middle point */\n            else {\n                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());\n                this.bv = bvMiddle;\n            }\n            return this.bv;\n        }\n\n        /**\n         * Set overlapping between two coincident boundary edges\n         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n         * @param edge\n         */\n        setOverlap(edge) {\n            let flag = undefined;\n            let shape1 = this.shape;\n            let shape2 = edge.shape;\n\n            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n                    flag = Flatten.OVERLAP_SAME;\n                }\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n                    flag = Flatten.OVERLAP_OPPOSITE;\n                }\n            }\n            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.counterClockwise === shape2.counterClockwise &&\n                    shape1.middle().equalTo(shape2.middle())) {\n                    flag = Flatten.OVERLAP_SAME;\n                }\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.counterClockwise !== shape2.counterClockwise &&\n                    shape1.middle().equalTo(shape2.middle())) {\n                    flag = Flatten.OVERLAP_OPPOSITE;\n                }\n            }\n            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\n                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n                    flag = Flatten.OVERLAP_SAME;\n                }\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n                    flag = Flatten.OVERLAP_OPPOSITE;\n                }\n            }\n\n            /* Do not update overlap flag if already set on previous chain */\n            if (this.overlap === undefined) this.overlap = flag;\n            if (edge.overlap === undefined) edge.overlap = flag;\n        }\n\n        svg() {\n            if (this.shape instanceof Flatten.Segment) {\n                return ` L${this.shape.end.x},${this.shape.end.y}`;\n            }\n            else if (this.shape instanceof  Flatten.Arc) {\n                let arc = this.shape;\n                let largeArcFlag;\n                let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n                // Draw full circe arc as special case: split it into two half-circles\n                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {\n                    let sign = arc.counterClockwise ? 1 : -1;\n                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);\n                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);\n\n                    largeArcFlag = \"0\";\n\n                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\n                }\n                else {\n                    largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n                }\n            }\n        }\n\n        toJSON() {\n            let json = this.shape.clone();\n            // json.name = this.shape.constructor.name;          // not pass webpack minification\n            json.name = this.shape instanceof  Flatten.Segment ? \"segment\" : \"arc\";\n            return json;\n        }\n    };\n};","/**\n * Created by Alex Bol on 3/7/2017.\n */\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    /**\n     * Class Box represent bounding box of the shape\n     * @type {Box}\n     */\n    Flatten.Box = class Box {\n        /**\n         *\n         * @param {number} xmin - minimal x coordinate\n         * @param {number} ymin - minimal y coordinate\n         * @param {number} xmax - maximal x coordinate\n         * @param {number} ymax - maximal y coordinate\n         */\n        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {\n            /**\n             * Minimal x coordinate\n             * @type {number}\n             */\n            this.xmin = xmin;\n            /**\n             * Minimal y coordinate\n             * @type {number}\n             */\n            this.ymin = ymin;\n            /**\n             * Maximal x coordinate\n             * @type {number}\n             */\n            this.xmax = xmax;\n            /**\n             * Maximal y coordinate\n             * @type {number}\n             */\n            this.ymax = ymax;\n        }\n\n        /**\n         * Clones and returns new instance of box\n         * @returns {Box}\n         */\n        clone() {\n            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n        }\n\n        /**\n         * Property low need for interval tree interface\n         * @returns {Point}\n         */\n        get low() {\n            return new Flatten.Point(this.xmin, this.ymin);\n        }\n\n        /**\n         * Property high need for interval tree interface\n         * @returns {Point}\n         */\n        get high() {\n            return new Flatten.Point(this.xmax, this.ymax);\n        }\n\n        /**\n         * Property max returns the box itself !\n         * @returns {Box}\n         */\n        get max() {\n            return this.clone();\n        }\n\n        /**\n         * Returns true if not intersected with other box\n         * @param {Box} other_box - other box to test\n         * @returns {boolean}\n         */\n        notIntersect(other_box) {\n            return (\n                this.xmax < other_box.xmin ||\n                this.xmin > other_box.xmax ||\n                this.ymax < other_box.ymin ||\n                this.ymin > other_box.ymax\n            );\n        }\n\n        /**\n         * Returns true if intersected with other box\n         * @param {Box} other_box - Query box\n         * @returns {boolean}\n         */\n        intersect(other_box) {\n            return !this.notIntersect(other_box);\n        }\n\n        /**\n         * Returns new box merged with other box\n         * @param {Box} other_box - Other box to merge with\n         * @returns {Box}\n         */\n        merge(other_box) {\n            return new Box(\n                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\n                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\n                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\n                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\n            );\n        }\n\n        /**\n         * Defines predicate \"less than\" between two boxes. Need for interval index\n         * @param {Box} other_box - other box\n         * @returns {boolean} - true if this box less than other box, false otherwise\n         */\n        less_than(other_box) {\n            if (this.low.lessThan(other_box.low))\n                return true;\n            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\n                return true;\n            return false;\n        }\n\n        /**\n         * Returns true if this box is equal to other box, false otherwise\n         * @param {Box} other_box - query box\n         * @returns {boolean}\n         */\n        equal_to(other_box) {\n            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\n        }\n\n        output() {\n            return this.clone();\n        }\n\n        maximal_val(box1, box2) {\n            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n            return box1.merge(box2);\n        }\n\n        val_less_than(pt1, pt2) {\n            return pt1.lessThan(pt2);\n        }\n\n        /**\n         * Set new values to the box object\n         * @param {number} xmin - miminal x coordinate\n         * @param {number} ymin - minimal y coordinate\n         * @param {number} xmax - maximal x coordinate\n         * @param {number} ymax - maximal y coordinate\n         */\n        set(xmin, ymin, xmax, ymax) {\n            this.xmin = xmin;\n            this.ymin = ymin;\n            this.xmax = xmax;\n            this.ymax = ymax;\n        }\n\n        /**\n         * Return string to draw circle in svg\n         * @param {Object} attrs - json structure with attributes of svg rectangle element,\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n         * @returns {string}\n         */\n        svg(attrs = {}) {\n            let {stroke, strokeWidth, fill, id, className} = attrs;\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n            let width = this.xmax - this.xmin;\n            let height = this.ymax - this.ymin;\n\n            return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\n        }\n    };\n};\n","/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    /**\n     * Class representing a circular arc\n     * @type {Arc}\n     */\n    Flatten.Arc = class Arc {\n        /**\n         *\n         * @param {Point} pc - arc center\n         * @param {number} r - arc radius\n         * @param {number} startAngle - start angle in radians from 0 to 2*PI\n         * @param {number} endAngle - end angle in radians from 0 to 2*PI\n         * @param {boolean} counterClockwise - arc direction, true - clockwise (or {@link Flatten.CCW}), false - counter clockwise (or {@link Flatten.CW)}\n         */\n        constructor(pc=new Flatten.Point(), r=1, startAngle=0, endAngle=2*Math.PI, counterClockwise=true) {\n            this.pc = pc.clone();\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n        }\n\n        /**\n         * Return new instance of arc\n         * @returns {Arc}\n         */\n        clone() {\n            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n        }\n\n        /**\n         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n         * @returns {number}\n         */\n        get sweep() {\n            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\n                return 0.0;\n            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n                return Flatten.PIx2;\n            }\n            let sweep;\n            if (this.counterClockwise) {\n                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\n                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n            } else {\n                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\n                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n            }\n\n            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {\n                sweep -= Flatten.PIx2;\n            }\n            if ( Flatten.Utils.LT(sweep, 0) ) {\n                sweep += Flatten.PIx2;\n            }\n            return sweep;\n        }\n\n        /**\n         * Get start point of arc\n         * @returns {Point}\n         */\n        get start() {\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n            return p0.rotate(this.startAngle, this.pc);\n        }\n\n        /**\n         * Get end point of arc\n         * @returns {Point}\n         */\n        get end() {\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n            return p0.rotate(this.endAngle, this.pc);\n        }\n\n        /**\n         * Get center of arc\n         * @returns {Point}\n         */\n        get center() {\n            return this.pc.clone();\n        }\n\n        get vertices() {\n            return [this.start.clone(), this.end.clone()];\n        }\n\n        /**\n         * Get arc length\n         * @returns {number}\n         */\n        get length() {\n            return Math.abs(this.sweep*this.r);\n        }\n\n        /**\n         * Get bounding box of the arc\n         * @returns {Box}\n         */\n        get box() {\n            let func_arcs = this.breakToFunctional();\n            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );\n            box = box.merge(this.end.box);\n            return box;\n        }\n\n        /**\n         * Returns true if arc contains point, false otherwise\n         * @param {Point} pt - point to test\n         * @returns {boolean}\n         */\n        contains(pt) {\n            // first check if  point on circle (pc,r)\n            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\n                return false;\n\n            // point on circle\n\n            if (pt.equalTo(this.start))\n                return true;\n\n            let angle = new Flatten.Vector(this.pc, pt).slope;\n            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n            return Flatten.Utils.LE(test_arc.length, this.length);\n        }\n\n        /**\n         * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n         * empty array.\n         * @param {Point} pt Query point\n         * @returns {Arc[]}\n         */\n        split(pt) {\n            if (!this.contains(pt))\n                return [];\n\n            if (Flatten.Utils.EQ_0(this.sweep))\n                return [this.clone()];\n\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\n                return [this.clone()];\n\n            let angle = new Flatten.Vector(this.pc, pt).slope;\n\n            return [\n                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n            ]\n        }\n\n        /**\n         * Return middle point of the arc\n         * @returns {Point}\n         */\n        middle() {\n            let endAngle = this.counterClockwise === Flatten.CCW ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;\n            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n            return arc.end;\n        }\n\n        /**\n         * Returns chord height (\"sagitta\") of the arc\n         * @returns {number}\n         */\n        chordHeight() {\n            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;\n        }\n\n        /**\n         * Returns array of intersection points between arc and other shape\n         * @param {Shape} shape Shape of the one of supported types Line, Circle, Segment, Arc <br/>\n         * TODO: support Polygon and Planar Set\n         * @returns {Points[]}\n         */\n        intersect(shape) {\n            if (shape instanceof Flatten.Line) {\n                return shape.intersect(this);\n            }\n            if (shape instanceof Flatten.Circle) {\n                return Arc.intersectArc2Circle(this, shape);\n            }\n            if (shape instanceof Flatten.Segment) {\n                return shape.intersect(this);\n            }\n            if (shape instanceof Flatten.Arc) {\n                return Arc.intersectArc2Arc(this, shape);\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n         * @returns {number} distance from arc to shape\n         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n\n            if (shape instanceof Flatten.Point) {\n                let [dist, shortest_segment] = Distance.point2arc(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                let [dist, shortest_segment] = Distance.arc2circle(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Line) {\n                let [dist, shortest_segment] = Distance.arc2line(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                let [dist, shortest_segment] = Distance.segment2arc(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                let [dist, shortest_segment] = Distance.arc2arc(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.PlanarSet) {\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\n                return [dist, shortest_segment];\n            }\n        }\n\n        /**\n         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n         * @returns {Arcs[]}\n         */\n        breakToFunctional() {\n            let func_arcs_array = [];\n            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];\n            let pts = [\n                this.pc.translate(this.r,0),\n                this.pc.translate(0,this.r),\n                this.pc.translate(-this.r,0),\n                this.pc.translate(0,-this.r)\n            ];\n\n            // If arc contains extreme point,\n            // create test arc started at start point and ended at this extreme point\n            let test_arcs = [];\n            for (let i=0; i < 4; i++) {\n                if (pts[i].on(this)) {\n                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n                }\n            }\n\n            if (test_arcs.length == 0) {                  // arc does contain any extreme point\n                func_arcs_array.push(this.clone());\n            }\n            else {                                        // arc passes extreme point\n                // sort these arcs by length\n                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n\n                for (let i = 0; i < test_arcs.length; i++) {\n                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                    let new_arc;\n                    if (prev_arc) {\n                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                    }\n                    else {\n                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                    }\n                    if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                        func_arcs_array.push(new_arc.clone());\n                    }\n                }\n\n                // add last sub arc\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) {\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n                }\n                else {\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n                }\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                    func_arcs_array.push(new_arc.clone());\n                }\n            }\n            return func_arcs_array;\n        }\n\n        /**\n         * Return tangent unit vector in the start point in the direction from start to end\n         * @returns {Vector}\n         */\n        tangentInStart() {\n            let vec = new Flatten.Vector(this.pc, this.start);\n            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;\n            let tangent = vec.rotate(angle).normalize();\n            return tangent;\n        }\n\n        /**\n         * Return tangent unit vector in the end point in the direction from end to start\n         * @returns {Vector}\n         */\n        tangentInEnd() {\n            let vec = new Flatten.Vector(this.pc, this.end);\n            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;\n            let tangent = vec.rotate(angle).normalize();\n            return tangent;\n        }\n\n        /**\n         * Returns new arc with swapped start and end angles and reversed direction\n         * @returns {Arc}\n         */\n        reverse() {\n            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n        }\n\n        /**\n         * Returns new arc translated by vector vec\n         * @param {Vector} vec\n         * @returns {Segment}\n         */\n        translate(vec) {\n            let arc = this.clone();\n            arc.pc = this.pc.translate(vec);\n            return arc;\n        }\n\n        static intersectArc2Arc(arc1, arc2) {\n            var ip = [];\n\n            if (arc1.box.notIntersect(arc2.box)) {\n                return ip;\n            }\n\n            // Special case: overlapping arcs\n            // May return up to 4 intersection points\n            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n                let pt;\n\n                pt = arc1.start;\n                if (pt.on(arc2))\n                    ip.push(pt);\n\n                pt = arc1.end;\n                if (pt.on(arc2))\n                    ip.push(pt);\n\n                pt = arc2.start;\n                if (pt.on(arc1)) ip.push(pt);\n\n                pt = arc2.end;\n                if (pt.on(arc1)) ip.push(pt);\n\n                return ip;\n            }\n\n            // Common case\n            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n            let ip_tmp =  circle1.intersect(circle2);\n            for (let pt of ip_tmp) {\n                if (pt.on(arc1) && pt.on(arc2)) {\n                    ip.push(pt);\n                }\n            }\n            return ip;\n        }\n\n        static intersectArc2Circle(arc, circle) {\n            let ip = [];\n\n            if (arc.box.notIntersect(circle.box)) {\n                return ip;\n            }\n\n            // Case when arc center incident to circle center\n            // Return arc's end points as 2 intersection points\n            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n                ip.push(arc.start);\n                ip.push(arc.end);\n                return ip;\n            }\n\n            // Common case\n            let circle1 = circle;\n            let circle2 = new Flatten.Circle(arc.pc, arc.r);\n            let ip_tmp = circle1.intersect(circle2);\n            for (let pt of ip_tmp) {\n                if (pt.on(arc)) {\n                    ip.push(pt);\n                }\n            }\n            return ip;\n        }\n\n        definiteIntegral(ymin=0) {\n            let f_arcs = this.breakToFunctional();\n            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );\n            return area;\n        }\n\n        circularSegmentDefiniteIntegral(ymin) {\n            let line = new Flatten.Line(this.start, this.end);\n            let onLeftSide = this.pc.leftTo(line);\n            let segment = new Flatten.Segment(this.start, this.end);\n            let areaTrapez = segment.definiteIntegral(ymin);\n            let areaCircularSegment = this.circularSegmentArea();\n            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n            return area;\n        }\n\n        circularSegmentArea() {\n            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))\n        }\n\n        /**\n         * Return string to draw arc in svg\n         * @param {Object} attrs - json structure with attributes of svg path element,\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n         * @returns {string}\n         */\n        svg(attrs = {}) {\n            let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n            let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n            let {stroke, strokeWidth, fill, id, className} = attrs;\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {\n                let circle = new Flatten.Circle(this.pc, this.r);\n                return circle.svg(attrs);\n            }\n            else {\n                return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\n            }\n        }\n    };\n\n    /**\n     * Function to create arc equivalent to \"new\" constructor\n     * @param args\n     */\n    Flatten.arc = (...args) => new Flatten.Arc(...args);\n};","/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function (Flatten) {\n    /**\n     * Class representing a segment\n     * @type {Segment}\n     */\n    Flatten.Segment = class Segment {\n        /**\n         *\n         * @param {Point} ps - start point\n         * @param {Point} pe - end point\n         */\n        constructor(...args) {\n            /**\n             * Start point\n             * @type {Point}\n             */\n            this.ps = new Flatten.Point();\n            /**\n             * End Point\n             * @type {Point}\n             */\n            this.pe = new Flatten.Point();\n\n            if (args.length == 0) {\n                return;\n            }\n\n            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {\n                let coords = args[0];\n                this.ps = new Flatten.Point(coords[0], coords[1]);\n                this.pe = new Flatten.Point(coords[2], coords[3]);\n                return;\n            }\n\n            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n                this.ps = args[0].clone();\n                this.pe = args[1].clone();\n                return;\n            }\n\n            if (args.length == 4) {\n                this.ps = new Flatten.Point(args[0], args[1]);\n                this.pe = new Flatten.Point(args[2], args[3]);\n                return;\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\n         * Method clone copies segment and returns a new instance\n         * @returns {Segment}\n         */\n        clone() {\n            return new Flatten.Segment(this.start, this.end);\n        }\n\n        /**\n         * Start point\n         * @returns {Point}\n         */\n        get start() {\n            return this.ps;\n        }\n\n        /**\n         * End point\n         * @returns {Point}\n         */\n        get end() {\n            return this.pe;\n        }\n\n\n        /**\n         * Returns array of start and end point\n         * @returns [Point,Point]\n         */\n        get vertices() {\n            return [this.ps.clone(), this.pe.clone()];\n        }\n\n        /**\n         * Length of a segment\n         * @returns {number}\n         */\n        get length() {\n            return this.start.distanceTo(this.end)[0];\n        }\n\n        /**\n         * Slope of the line - angle to axe x in radians from 0 to 2PI\n         * @returns {number}\n         */\n        get slope() {\n            let vec = new Flatten.Vector(this.start, this.end);\n            return vec.slope;\n        }\n\n        /**\n         * Bounding box\n         * @returns {Box}\n         */\n        get box() {\n            return new Flatten.Box(\n                Math.min(this.start.x, this.end.x),\n                Math.min(this.start.y, this.end.y),\n                Math.max(this.start.x, this.end.x),\n                Math.max(this.start.y, this.end.y)\n            )\n        }\n\n        /**\n         * Returns true if segment contains point\n         * @param {Point} pt Query point\n         * @returns {boolean}\n         */\n        contains(pt) {\n            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n        }\n\n        /**\n         * Returns array of intersection points between segment and other shape\n         * @param {Shape} shape - Shape of the one of supported types Line, Circle, Segment, Arc <br/>\n         * TODO: support Polygon and Planar Set\n         * @returns {Point[]}\n         */\n        intersect(shape) {\n            if (shape instanceof Flatten.Line) {\n                return Segment.intersectSegment2Line(this, shape);\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                return Segment.intersectSegment2Segment(this, shape);\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                return Segment.intersectSegment2Circle(this, shape);\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                return Segment.intersectSegment2Arc(this, shape);\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n         * @returns {number} distance from segment to shape\n         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n\n            if (shape instanceof Flatten.Point) {\n                let [dist, shortest_segment] = Distance.point2segment(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                let [dist, shortest_segment] = Distance.segment2circle(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Line) {\n                let [dist, shortest_segment] = Distance.segment2line(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                let [dist, shortest_segment] = Distance.segment2segment(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                let [dist, shortest_segment] = Distance.segment2arc(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\n                return [dist, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.PlanarSet) {\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\n                return [dist, shortest_segment];\n            }\n        }\n\n        /**\n         * Returns unit vector in the direction from start to end\n         * @returns {Vector}\n         */\n        tangentInStart() {\n            let vec = new Flatten.Vector(this.start, this.end);\n            return vec.normalize();\n        }\n\n        /**\n         * Return unit vector in the direction from end to start\n         * @returns {Vector}\n         */\n        tangentInEnd() {\n            let vec = new Flatten.Vector(this.end, this.start);\n            return vec.normalize();\n        }\n\n        /**\n         * Returns new segment with swapped start and end points\n         * @returns {Segment}\n         */\n        reverse() {\n            return new Segment(this.end, this.start);\n        }\n\n        /**\n         * When point belongs to segment, return array of two segments split by given point,\n         * if point is inside segment. Returns clone of this segment if query point is incident\n         * to start or end point of the segment. Returns empty array if point does not belong to segment\n         * @param {Point} pt Query point\n         * @returns {Segment[]}\n         */\n        split(pt) {\n            if (!this.contains(pt))\n                return [];\n\n            if (this.start.equalTo(this.end))\n                return [this.clone()];\n\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\n                return [this];\n\n            return [\n                new Flatten.Segment(this.start, pt),\n                new Flatten.Segment(pt, this.end)\n            ]\n        }\n\n        /**\n         * Return middle point of the segment\n         * @returns {Point}\n         */\n        middle() {\n            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);\n        }\n\n        distanceToPoint(pt) {\n            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n            return dist;\n        };\n\n        definiteIntegral(ymin = 0.0) {\n            let dx = this.end.x - this.start.x;\n            let dy1 = this.start.y - ymin;\n            let dy2 = this.end.y - ymin;\n            return ( dx * (dy1 + dy2) / 2 );\n        }\n\n        /**\n         * Returns new segment translated by vector vec\n         * @param {Vector} vec\n         * @returns {Segment}\n         */\n        translate(vec) {\n            return new Segment(this.ps.translate(vec), this.pe.translate(vec));\n        }\n\n        static intersectSegment2Line(seg, line) {\n            let ip = [];\n            let zero_segment = Flatten.Utils.EQ_0(seg.length);\n\n            // Boundary cases\n            if (seg.ps.on(line)) {\n                ip.push(seg.ps);\n            }\n            // If both ends lay on line, return two intersection points\n            if (seg.pe.on(line) && !zero_segment) {\n                ip.push(seg.pe);\n            }\n\n            if (ip.length > 0) {\n                return ip;          // done, intersection found\n            }\n\n            // Not a boundary case, check if both points are on the same side and\n            // hence there is no intersection\n            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\n                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n                return ip;\n            }\n\n            // Calculate intersection between lines\n            let line1 = new Flatten.Line(seg.ps, seg.pe);\n            return line1.intersect(line);\n        }\n\n        static intersectSegment2Segment(seg1, seg2) {\n            let ip = [];\n\n            // quick reject\n            if (seg1.box.notIntersect(seg2.box)) {\n                return ip;\n            }\n\n            let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n            let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n            // Check overlapping between segments in case of incidence\n            // If segments touching, add one point. If overlapping, add two points\n            if (line1.incidentTo(line2)) {\n                if (seg1.ps.on(seg2)) {\n                    ip.push(seg1.ps);\n                }\n                if (seg1.pe.on(seg2)) {\n                    ip.push(seg1.pe);\n                }\n                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n                    ip.push(seg2.ps);\n                }\n                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n                    ip.push(seg2.pe);\n                }\n            }\n            else {                /* not incident - parallel or intersect */\n                // Calculate intersection between lines\n                let new_ip = line1.intersect(line2);\n                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\n                    ip.push(new_ip[0]);\n                }\n            }\n\n            return ip;\n        }\n\n        static intersectSegment2Circle(segment, circle) {\n            let ips = [];\n\n            if (segment.box.notIntersect(circle.box)) {\n                return ips;\n            }\n\n            let line = new Flatten.Line(segment.ps, segment.pe);\n\n            let ips_tmp = line.intersect(circle);\n\n            for (let ip of ips_tmp) {\n                if (ip.on(segment)) {\n                    ips.push(ip);\n                }\n            }\n\n            return ips;\n        }\n\n        static intersectSegment2Arc(segment, arc) {\n            let ip = [];\n\n            if (segment.box.notIntersect(arc.box)) {\n                return ip;\n            }\n\n            let line = new Flatten.Line(segment.ps, segment.pe);\n            let circle = new Flatten.Circle(arc.pc, arc.r);\n\n            let ip_tmp = line.intersect(circle);\n\n            for (let pt of ip_tmp) {\n                if (pt.on(segment) && pt.on(arc)) {\n                    ip.push(pt);\n                }\n            }\n            return ip;\n\n        }\n\n        /**\n         * Return string to draw segment in svg\n         * @param {Object} attrs - Object with attributes for svg path element,\n         * like \"stroke\", \"strokeWidth\" <br/>\n         * Defaults are stroke:\"black\", strokeWidth:\"1\"\n         * @returns {string}\n         */\n        svg(attrs = {}) {\n            let {stroke, strokeWidth, id, className} = attrs;\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n            return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\n\n        }\n    };\n\n    /**\n     * Shortcut method to create new segment\n     */\n    Flatten.segment = (...args) => new Flatten.Segment(...args);\n};","/**\n * Created by Alex Bol on 3/6/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    let {Arc,vector} = Flatten;\n    /**\n     * Class representing a circle\n     * @type {Circle}\n     */\n    Flatten.Circle = class Circle {\n        /**\n         *\n         * @param {Point} pc - circle center point\n         * @param {number} r - circle radius\n         */\n        constructor(pc, r) {\n            /**\n             * Circle center\n             * @type {Point}\n             */\n            this.pc = pc;\n            /**\n             * Circle radius\n             * @type {number}\n             */\n            this.r = r;\n        }\n\n        /**\n         * Method clone returns new instance of a Circle\n         * @returns {Circle}\n         */\n        clone() {\n            return new Flatten.Circle(this.pc.clone(), this.r);\n        }\n\n        /**\n         * Circle center\n         * @returns {Point}\n         */\n        get center() {\n            return this.pc;\n        }\n\n        /**\n         * Circle bounding box\n         * @returns {Box}\n         */\n        get box() {\n            return new Flatten.Box(\n                this.pc.x - this.r,\n                this.pc.y - this.r,\n                this.pc.x + this.r,\n                this.pc.y + this.r\n            );\n        }\n\n        /**\n         * Return true if circle contains point\n         * @param {Point} pt - test point\n         * @returns {boolean}\n         */\n        contains(pt) {\n            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\n        }\n\n        /**\n         * Transform circle to closed arc\n         * @param {boolean} counterclockwise\n         * @returns {Arc}\n         */\n        toArc(counterclockwise=true) {\n            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n        }\n\n        /**\n         * Returns array of intersection points between circle and other shape\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc\n         * @returns {Point[]}\n         */\n        intersect(shape) {\n            if (shape instanceof Flatten.Line) {\n                return shape.intersect(this);\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                return shape.intersect(this);\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                return Circle.intersectCirle2Circle(this, shape);\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                return shape.intersect(this);\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n         * @returns {number} distance from circle to shape\n         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;\n\n            if (shape instanceof Flatten.Point) {\n                let [distance, shortest_segment] = point2circle(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                let [distance, shortest_segment] = circle2circle(this, shape);\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Line) {\n                let [distance, shortest_segment] = circle2line(this, shape);\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                let [distance, shortest_segment] = segment2circle(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                let [distance, shortest_segment] = arc2circle(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.PlanarSet) {\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\n                return [dist, shortest_segment];\n            }\n        }\n\n        static intersectCirle2Circle(circle1, circle2) {\n            let ip = [];\n\n            if (circle1.box.notIntersect(circle2.box)) {\n                return ip;\n            }\n\n            let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n            let r1 = circle1.r;\n            let r2 = circle2.r;\n\n            // Degenerated circle\n            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\n                return ip;\n\n            // In case of equal circles return one leftmost point\n            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n                ip.push(circle1.pc.translate(-r1, 0));\n                return ip;\n            }\n\n            let dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\n                return ip;\n\n            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\n                return ip;\n\n            // Normalize vector.\n            vec.x /= dist;\n            vec.y /= dist;\n\n            let pt;\n\n            // Case of touching from outside or from inside - single intersection point\n            // TODO: check this specifically not sure if correct\n            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);\n                ip.push(pt);\n                return ip;\n            }\n\n            // Case of two intersection points\n\n            // Distance from first center to center of common chord:\n            //   a = (r1^2 - r2^2 + d^2) / 2d\n            // Separate for better accuracy\n            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;\n\n            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);\n            let h = Math.sqrt(r1*r1 - a*a);\n            // let norm;\n\n            // norm = vec.rotate90CCW().multiply(h);\n            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n            ip.push(pt);\n\n            // norm = vec.rotate90CW();\n            pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n            ip.push(pt);\n\n            return ip;\n        }\n\n        /**\n         * Return string to draw circle in svg\n         * @param {Object} attrs - json structure with attributes of svg circle element,\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\n         * @returns {string}\n         */\n        svg(attrs = {}) {\n            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n\n            return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\n        }\n    };\n\n    /**\n     * Shortcut to create new circle\n     * @param args\n     */\n    Flatten.circle = (...args) => new Flatten.Circle(...args);\n};","/**\n * Created by Alex Bol on 2/20/2017.\n */\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    /**\n     * Class representing a line\n     * @type {Line}\n     */\n    Flatten.Line = class Line {\n        /**\n         * Line may be constructed by point and normal vector or by two points that a line passes through\n         * @param {Point} pt - point that a line passes through\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n         */\n        constructor(...args) {\n            /**\n             * Point a line passes through\n             * @type {Point}\n             */\n            this.pt = new Flatten.Point();\n            /**\n             * Normal unit vector to a line\n             * @type {Vector}\n             */\n            this.norm = new Flatten.Vector(0,1);\n\n            if (args.length == 0) {\n                return;\n            }\n\n            if (args.length == 2) {\n                let a1 = args[0];\n                let a2 = args[1];\n\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                    this.pt = a1;\n                    this.norm = Line.points2norm(a1, a2);\n                    return;\n                }\n\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                    }\n                    this.pt = a1.clone();\n                    this.norm = a2.clone();\n                    return;\n                }\n\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\n                    }\n                    this.pt = a2.clone();\n                    this.norm = a1.clone();\n                    return;\n                }\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\n         * Returns cloned new instance of a line\n         * @returns {Line}\n         */\n        clone() {\n            return new Flatten.Line(this.pt, this.norm);\n        }\n\n        /**\n         * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n         * @returns {number} - slope of the line\n         */\n        get slope() {\n            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n            return vec.slope;\n        }\n\n        /**\n         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n         * @code [A, B, C] = line.standard\n         * @returns {number[]} - array of coefficients\n         */\n        get standard() {\n            let A = this.norm.x;\n            let B = this.norm.y;\n            let C = this.norm.dot(this.pt);\n\n            return [A,B,C];\n        }\n\n        /**\n         * Return true if parallel or incident to other line\n         * @param {Line} other_line - line to check\n         * @returns {boolean}\n         */\n        parallelTo(other_line) {\n            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n        }\n\n        /**\n         * Returns true if incident to other line\n         * @param {Line} other_line - line to check\n         * @returns {boolean}\n         */\n        incidentTo(other_line) {\n            return ( (this.norm.equalTo(other_line.norm) || this.norm.equalTo(other_line.norm.invert())) &&\n                this.pt.on(other_line));\n        }\n\n        /**\n         * Returns true if point belongs to line\n         * @param {Point} pt Query point\n         * @returns {boolean}\n         */\n        contains(pt) {\n            if (this.pt.equalTo(pt)) {\n                return true;\n            }\n            /* Line contains point if vector to point is orthogonal to the line normal vector */\n            let vec = new Flatten.Vector(this.pt, pt);\n            return Flatten.Utils.EQ_0(this.norm.dot(vec));\n        }\n\n        /**\n         * Returns array of intersection points\n         * @param {Shape} shape - shape to intersect with of the type Line, Circle, Segment, Arc\n         * @returns {Point[]}\n         */\n        intersect(shape) {\n            if (shape instanceof Flatten.Line) {\n                return Line.intersectLine2Line(this, shape);\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                return Line.intersectLine2Circle(this, shape);\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                return shape.intersect(this);\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                return Line.intersectLine2Arc(this, shape);\n            }\n        }\n\n        /**\n         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n         * @returns {Number}\n         * @returns {Segment}\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n\n            if (shape instanceof Flatten.Point) {\n                let [distance, shortest_segment] = Distance.point2line(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                let [distance, shortest_segment] = Distance.circle2line(shape, this);\n                shortest_segment = shortest_segment.reverse();\n                return [distance, shortest_segment];\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                let [distance, shortest_segment] = Distance.segment2line(shape, this);\n                return [distance, shortest_segment.reverse()];\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                let [distance, shortest_segment] = Distance.arc2line(shape, this);\n                return [distance, shortest_segment.reverse()];\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\n                return [distance, shortest_segment];\n            }\n        }\n\n        /**\n         * Return string to draw svg segment representing line inside given box\n         * @param {Box} box Box representing drawing area\n         * @param {Object} attrs - json structure with attributes of svg circle element\n         */\n        svg(box, attrs = {}) {\n            let ip = Line.intersectLine2Box(this, box);\n            if (ip.length === 0)\n                return \"\";\n            let ps = ip[0];\n            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );\n            if (pe === undefined) pe = ps;\n            let segment = new Flatten.Segment(ps, pe);\n            return segment.svg(attrs);\n        }\n\n        static points2norm(pt1, pt2) {\n            if (pt1.equalTo(pt2)) {\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\n            }\n            let vec = new Flatten.Vector(pt1, pt2);\n            let unit = vec.normalize();\n            return unit.rotate90CCW();\n        }\n\n        static intersectLine2Line(line1, line2) {\n            let ip = [];\n\n            let [A1, B1, C1] = line1.standard;\n            let [A2, B2, C2] = line2.standard;\n\n            /* Cramer's rule */\n            let det = A1*B2 - B1*A2;\n            let detX = C1*B2 - B1*C2;\n            let detY = A1*C2 - C1*A2;\n\n            if (!Flatten.Utils.EQ_0(det)) {\n                let new_ip = new Flatten.Point( detX/det, detY/det );\n                ip.push(new_ip);\n            }\n            return ip;\n        }\n\n        static intersectLine2Circle(line, circle) {\n            let ip = [];\n            let prj = circle.pc.projectionOn(line);            // projection of circle center on line\n            let dist = circle.pc.distanceTo(prj)[0];              // distance from circle center to projection\n\n            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\n                ip.push(prj);\n            }\n            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\n                var delta = Math.sqrt(circle.r*circle.r - dist*dist);\n                var v_trans, pt;\n\n                v_trans = line.norm.rotate90CCW().multiply(delta);\n                pt = prj.translate(v_trans);\n                ip.push(pt);\n\n                v_trans = line.norm.rotate90CW().multiply(delta);\n                pt = prj.translate(v_trans);\n                ip.push(pt);\n            }\n            return ip;\n        }\n\n        static intersectLine2Box(line, box) {\n            let pts = [\n                new Flatten.Point(box.xmin, box.ymin),\n                new Flatten.Point(box.xmax, box.ymin),\n                new Flatten.Point(box.xmax, box.ymax),\n                new Flatten.Point(box.xmin, box.ymax)\n            ];\n            let segs = [\n                new Flatten.Segment(pts[0], pts[1]),\n                new Flatten.Segment(pts[1], pts[2]),\n                new Flatten.Segment(pts[2], pts[3]),\n                new Flatten.Segment(pts[3], pts[0])\n            ];\n\n            let ips =  [];\n\n            for(let seg of segs) {\n                let ips_tmp = seg.intersect(line);\n                for (let ip of ips_tmp) {\n                    ips.push(ip);\n                }\n            };\n            return ips;\n        }\n\n        static intersectLine2Arc(line, arc) {\n            let ip = [];\n\n            if (Line.intersectLine2Box(line, arc.box).length == 0) {\n                return ip;\n            }\n\n            let circle = new Flatten.Circle(arc.pc, arc.r);\n            let ip_tmp = line.intersect(circle);\n            for (let pt of ip_tmp) {\n                if (pt.on(arc)) {\n                    ip.push(pt);\n                }\n            }\n\n            return ip;\n        }\n    };\n\n    /**\n     * Function to create line equivalent to \"new\" constructor\n     * @param args\n     */\n    Flatten.line = (...args) => new Flatten.Line(...args);\n};\n","/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\"use strict\";\n\nmodule.exports = function(Flatten) {\n    /**\n     * Class representing a vector\n     * @type {Vector}\n     */\n    Flatten.Vector = class Vector {\n        /**\n         * Vector may be constructed by two points, or by two float numbers\n         * @param {Point} ps - start point\n         * @param {Point} pe - end point\n         */\n        constructor(...args) {\n            /**\n             * x-coordinate of a vector (float number)\n             * @type {number}\n             */\n            this.x = 0;\n            /**\n             * y-coordinate of a vector (float number)\n             * @type {number}\n             */\n            this.y = 0;\n\n            /* return zero vector */\n            if (args.length == 0) {\n                return;\n            }\n\n            if (args.length == 2) {\n                let a1 = args[0];\n                let a2 = args[1];\n\n                if (typeof(a1) == \"number\" && typeof(a2) == \"number\") {\n                    this.x = a1;\n                    this.y = a2;\n                    return;\n                }\n\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                    this.x = a2.x - a1.x;\n                    this.y = a2.y - a1.y;\n                    return;\n                }\n\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\n         * Method clone returns new instance of Vector\n         * @returns {Vector}\n         */\n        clone() {\n            return new Vector(this.x, this.y);\n        }\n\n        /**\n         * Slope of the vector in radians from 0 to 2PI\n         * @returns {number}\n         */\n        get slope() {\n            let angle = Math.atan2(this.y, this.x);\n            if (angle<0) angle = 2*Math.PI + angle;\n            return angle;\n        }\n\n        /**\n         * Length of vector\n         * @returns {number}\n         */\n        get length() {\n            return Math.sqrt(this.dot(this));\n        }\n\n        /**\n         * Returns true if vectors are equal up to DP_TOL tolerance\n         * @param {Vector} v\n         * @returns {boolean}\n         */\n        equalTo(v) {\n            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n        }\n\n        /**\n         * Returns new vector multiplied by scalar\n         * @param {number} scalar\n         * @returns {Vector}\n         */\n        multiply(scalar) {\n            return ( new Vector(scalar * this.x, scalar * this.y) );\n        }\n\n        /**\n         * Returns scalar product between two vectors <br/>\n         * <code>dot_product = (this * v)</code>\n         * @param {Vector} v Other vector\n         * @returns {number}\n         */\n        dot(v) {\n            return ( this.x * v.x + this.y * v.y );\n        }\n\n        /**\n         * Returns vector product (magnitude) between two vectors <br/>\n         * <code>cross_product = (this x v)</code>\n         * @param {Vector} v Other vector\n         * @returns {number}\n         */\n        cross(v) {\n            return ( this.x * v.y - this.y * v.x );\n        }\n\n        /**\n         * Returns unit vector.<br/>\n         * Throw error if given vector has zero length\n         * @returns {Vector}\n         */\n        normalize() {\n            if (!Flatten.Utils.EQ_0(this.length)) {\n                return ( new Vector(this.x / this.length, this.y / this.length) );\n            }\n            throw Flatten.Errors.ZERO_DIVISION;\n        }\n\n        /**\n         * Returns new vector rotated by given angle, positive angle defines rotation in counter clockwise direction\n         * @param {number} angle - Angle in radians\n         * @returns {Vector}\n         */\n        rotate(angle) {\n            let point = new Flatten.Point(this.x, this.y);\n            let rpoint = point.rotate(angle);\n            return new Flatten.Vector(rpoint.x, rpoint.y);\n        }\n\n        /**\n         * Returns vector rotated 90 degrees counter clockwise\n         * @returns {Vector}\n         */\n        rotate90CCW() {\n            return new Flatten.Vector(-this.y, this.x);\n        };\n\n        /**\n         * Returns vector rotated 90 degrees clockwise\n         * @returns {Vector}\n         */\n        rotate90CW() {\n            return new Flatten.Vector(this.y, -this.x);\n        };\n\n        /**\n         * Return inverted vector\n         * @returns {Vector}\n         */\n        invert() {\n            return new Flatten.Vector(-this.x, -this.y);\n        }\n    };\n\n    /**\n     * Function to create vector equivalent to \"new\" constructor\n     * @param args\n     */\n    Flatten.vector = (...args) => new Flatten.Vector(...args);\n};\n","/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n *\n * @param Flatten\n */\nmodule.exports = function(Flatten) {\n    /**\n     *\n     * Class representing a point\n     * @type {Point}\n     */\n    Flatten.Point = class Point {\n        /**\n         *\n         * @param {number} x - x-coordinate (float number)\n         * @param {number} y - y-coordinate (float number)\n         */\n        constructor(x = 0, y = 0) {\n            /**\n             * x-coordinate (float number)\n             * @type {number}\n             */\n            this.x = Number.isNaN(x) ? 0 : x;\n            /**\n             * y-coordinate (float number)\n             * @type {number}\n             */\n            this.y = Number.isNaN(y) ? 0: y;\n        }\n\n        /**\n         * Returns bounding box of a point\n         * @returns {Box}\n         */\n        get box() {\n            return new Flatten.Box(this.x, this.y, this.x, this.y);\n        }\n\n        /**\n         * Method clone returns new copied instance of point\n         * @returns {Point}\n         */\n        clone() {\n            return new Flatten.Point(this.x, this.y);\n        }\n\n        get vertices() {\n            return [this.clone()];\n        }\n\n        /**\n         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n         * @param {Point} pt Query point\n         * @returns {boolean}\n         */\n        equalTo(pt) {\n            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n        }\n\n        /**\n         * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\n         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n         * @param {Point} pt Query point\n         * @returns {boolean}\n         */\n        lessThan(pt) {\n            if (Flatten.Utils.LT(this.y, pt.y))\n                return true;\n            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\n                return true;\n            return false;\n        }\n\n        /**\n         * Returns new point rotated by given angle around given center point.\n         * If center point is omitted, rotates around zero point (0,0).\n         * Positive value of angle defines rotation in counter clockwise direction,\n         * negative angle defines rotation in clockwise clockwise direction\n         * @param {number} angle - angle in radians\n         * @param {Point} [center=(0,0)] center\n         * @returns {Point}\n         */\n        rotate(angle, center = {x:0, y:0}) {\n            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\n            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\n\n            return new Flatten.Point(x_rot, y_rot);\n        }\n\n        /**\n         * Returns new point translated by given vector.\n         * Translation vector may by also defined by a pair of numbers.\n         * @param {Vector} vector - Translation vector defined as Flatten.Vector or\n         * @param {number|number} - Translation vector defined as pair of numbers\n         * @returns {Point}\n         */\n        translate(...args) {\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\n                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\n            }\n\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\n                return new Flatten.Point(this.x + args[0], this.y + args[1]);\n            }\n\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\n        }\n\n        /**\n         * Returns projection point on given line\n         * @param {Line} line Line this point be projected on\n         * @returns {Point}\n         */\n        projectionOn(line) {\n            if (this.equalTo(line.pt))                   // this point equal to line anchor point\n                return this.clone();\n\n            let vec = new Flatten.Vector(this, line.pt);\n            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\n                return line.pt.clone();\n\n            let dist = vec.dot(line.norm);             // signed distance\n            let proj_vec = line.norm.multiply(dist);\n            return this.translate(proj_vec);\n        }\n\n        /**\n         * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n         * Return false if point belongs to the \"right\" semi-plane or to the line itself\n         * @param {Line} line Query line\n         * @returns {boolean}\n         */\n        leftTo(line) {\n            let vec = new Flatten.Vector(line.pt, this);\n            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n            return onLeftSemiPlane;\n        }\n\n        /**\n         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n         * @returns {number} distance from point to shape\n         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n         */\n        distanceTo(shape) {\n            let {Distance} = Flatten;\n\n            if (shape instanceof Point) {\n                let dx = shape.x - this.x;\n                let dy = shape.y - this.y;\n                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];\n            }\n\n            if (shape instanceof Flatten.Line) {\n                return Distance.point2line(this, shape);\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                return Distance.point2circle(this, shape);\n            }\n\n            if (shape instanceof Flatten.Segment) {\n                return Distance.point2segment(this, shape);\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                // let [dist, ...rest] = Distance.point2arc(this, shape);\n                // return dist;\n                return Distance.point2arc(this, shape);\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                // let [dist, ...rest] = Distance.point2polygon(this, shape);\n                // return dist;\n                return Distance.point2polygon(this, shape);\n            }\n\n            if (shape instanceof Flatten.PlanarSet) {\n                return Distance.shape2planarSet(this, shape);\n            }\n        }\n\n        /**\n         * Returns true if point is on a shape, false otherwise\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\n         * @returns {boolean}\n         */\n        on(shape) {\n            if (shape instanceof Flatten.Point) {\n                return this.equalTo(shape);\n            }\n\n            if (shape instanceof Flatten.Line) {\n                return shape.contains(this);\n            }\n\n            if (shape instanceof Flatten.Circle) {\n                return shape.contains(this);\n            }\n\n            if (shape instanceof  Flatten.Segment) {\n                return shape.contains(this);\n            }\n\n            if (shape instanceof Flatten.Arc) {\n                return shape.contains(this);\n            }\n\n            if (shape instanceof Flatten.Polygon) {\n                return shape.contains(this);\n            }\n        }\n\n        /**\n         * Return string to draw point in svg as circle with radius \"r\" <br/>\n         * Accept any valid attributes of svg elements as svg object\n         * Defaults attribues are: <br/>\n         * {\n         *    r:\"3\",\n         *    stroke:\"black\",\n         *    strokeWidth:\"1\",\n         *    fill:\"red\"\n         * }\n         * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n         * @returns {String}\n         */\n        svg(attrs = {}) {\n            let {r, stroke, strokeWidth, fill, id, className} = attrs;\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\n            return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\n        }\n\n    };\n\n    /**\n     * Function to create point equivalent to \"new\" constructor\n     * @param args\n     */\n    Flatten.point = (...args) => new Flatten.Point(...args);\n};\n","/**\n * Created by Alex Bol on 3/12/2017.\n */\n\n\"use strict\";\n\n// require(\"babel-polyfill\");\n\nlet IntervalTree = require('flatten-interval-tree');\n\nmodule.exports = function (Flatten) {\n    /**\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\n     * Set properties and methods\n     */\n    Flatten.PlanarSet = class PlanarSet extends Set {\n        /**\n         * Create new empty instance of PlanarSet\n         */\n        constructor() {\n            super();\n            this.index = new IntervalTree();\n        }\n\n        /**\n         * Add new shape to planar set and to its spatial index.<br/>\n         * If shape already exist, it will not be added again.\n         * This happens with no error, it is possible to use <i>size</i> property to check if\n         * a shape was actually added.<br/>\n         * Method returns planar set object updated and may be chained\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\n         * @returns {PlanarSet}\n         */\n        add(shape) {\n            let size = this.size;\n            super.add(shape);\n            // size not changed - item not added, probably trying to add same item twice\n            if (this.size > size) {\n                let node = this.index.insert(shape.box, shape);\n            }\n            return this;         // in accordance to Set.add interface\n        }\n\n        /**\n         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n         * @param {Shape} shape - shape to be deleted\n         * @returns {boolean}\n         */\n        delete(shape) {\n            let deleted = super.delete(shape);\n            if (deleted) {\n                this.index.remove(shape.box, shape);\n            }\n            return deleted;\n        }\n\n        // update(shape) {\n        //     if (super.has(shape)) {\n        //         this.delete(shape);\n        //     }\n        //     this.add(shape);\n        //\n        //     return this;\n        // }\n\n        clear() {\n\n        }\n\n        /**\n         * 2d range search in planar set.<br/>\n         * Returns array of all shapes in planar set which bounding box is intersected with query box\n         * @param {Box} box - query box\n         * @returns {Shapes[]}\n         */\n        search(box) {\n            let resp = this.index.search(box);\n            return resp;\n        }\n\n        /**\n         * Point location test. Returns array of shapes which contains given point\n         * @param {Point} point - query point\n         * @returns {Array}\n         */\n        hit(point) {\n            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n            let resp = this.index.search(box);\n            return resp.filter((shape) => point.on(shape));\n        }\n\n        /**\n         * Returns svg string to draw all shapes in planar set\n         * @returns {String}\n         */\n        svg() {\n            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n            return svgcontent;\n        }\n    }\n};\n\n","/**\n * Created by Alex Bol on 2/19/2017.\n */\nmodule.exports = {\n    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),\n    ZERO_DIVISION: new Error('Zero division')\n};\n\n","/**\n * Created by Alex Bol on 2/18/2017.\n */\n\nconst DP_TOL = 0.000001;\nconst DECIMALS = 3;\n\nmodule.exports = {\n    DP_TOL: DP_TOL,\n    /**\n     * @return {boolean}\n     */\n    EQ_0: function(x) {\n        return ( (x) < DP_TOL && (x) > -DP_TOL );\n    },\n    /**\n     * @return {boolean}\n     */\n    EQ: function(x,y) {\n        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );\n    },\n    /**\n     * @return {boolean}\n     */\n    GT: (x,y) => {\n        return ( (x)-(y) >  DP_TOL );\n    },\n    /**\n     * @return {boolean}\n     */\n    GE: (x,y) => {\n        return ( (x)-(y) > -DP_TOL );\n    },\n    /**\n     * @return {boolean}\n     */\n    LT: (x,y) => {\n        return ( (x)-(y) < -DP_TOL )\n    },\n    /**\n     * @return {boolean}\n     */\n    LE: (x,y) => {\n        return ( (x)-(y) <  DP_TOL );\n    }\n};\n","/**\n * Created by Alex Bol on 2/18/2017.\n */\n'use strict';\n\nlet Utils = require(\"./utils/utils\");\nlet Errors = require(\"./utils/errors\");\n\n/**\n * FlattenJS - library for 2d geometry\n * @type {Flatten}\n */\nlet Flatten = class Flatten {\n    constructor() {\n        this.DP_TOL = Utils.DP_TOL;\n        this.CCW = true;\n        this.CW = false;\n        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\n        this.PIx2 = 2 * Math.PI;\n        this.PI_2 = 0.5 * Math.PI;\n        this.Utils = Utils;\n        this.Errors = Errors;\n        this.INSIDE = 1;\n        this.OUTSIDE = 0;\n        this.BOUNDARY = 2;\n        this.CONTAINS = 3;\n        this.INTERLACE = 4;\n        this.CLIP_INSIDE = 1;\n        this.CLIP_OUTSIDE = 0;\n        this.BOOLEAN_UNION = 1;\n        this.BOOLEAN_INTERSECT = 2;\n        this.BOOLEAN_SUBTRACT = 3;\n        this.OVERLAP_SAME = 1;\n        this.OVERLAP_OPPOSITE = 2;\n    }\n};\n\nlet f = new Flatten();\n\nrequire(\"./data_structures/planar_set\")(f);\nrequire(\"./classes/point\")(f);\nrequire(\"./classes/vector\")(f);\nrequire(\"./classes/line\")(f);\nrequire(\"./classes/circle\")(f);\nrequire(\"./classes/segment\")(f);\nrequire(\"./classes/arc\")(f);\nrequire(\"./classes/box\")(f);\nrequire(\"./classes/edge\")(f);\nrequire(\"./classes/face\")(f);\nrequire(\"./classes/ray\")(f);\nrequire(\"./algorithms/ray_shooting\")(f);\nrequire(\"./classes/polygon\")(f);\nrequire(\"./algorithms/distance\")(f);\n\nmodule.exports = f;\n","/**\n * Created by Alex Bol on 12/02/2018.\n */\n\"use strict\";\nlet Flatten = require(\"flatten-js\");\n// let Flatten = require(\"flatten-js/dist/flatten.min\");\nlet {Polygon, Segment, Arc} = Flatten;\n\nconst NOT_VERTEX = 0;\nconst START_VERTEX = 1;\nconst END_VERTEX = 2;\n\n/**\n * Class BooleanOp implements boolean operations on polygons\n */\nclass BooleanOp {\n    static booleanOp(operands) {\n        let res_poly = new Polygon();\n        for (let [wrk_poly, op] of operands) {\n            res_poly = BooleanOp.booleanOpBinary(res_poly, wrk_poly, op);\n        }\n        return res_poly;\n    }\n\n    static booleanOpBinary(res_poly, wrk_poly, op) {\n        return BooleanOp.clip(res_poly, wrk_poly, op);\n    }\n\n    /**\n     * Unify two polygons polygons and returns new polygon. <br/>\n     * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n     * @param {Flatten.Polygon} polygon1 - first operand\n     * @param {Flatten.Polygon} polygon2 - second operand\n     * @returns {Flatten.Polygon}\n     */\n    static unify(polygon1, polygon2) {\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, polygon2, Flatten.BOOLEAN_UNION);\n        return res_poly;\n    }\n\n    /**\n     * Subtract second polygon from the first and returns new polygon\n     * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n     * @param {Flatten.Polygon} polygon1 - first operand\n     * @param {Flatten.Polygon} polygon2 - second operand\n     * @returns {Flatten.Polygon}\n     */\n    static subtract(polygon1, polygon2) {\n        let wrk_poly = polygon2.clone();\n        let wrk_poly_reversed = wrk_poly.reverse();\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, wrk_poly_reversed, Flatten.BOOLEAN_SUBTRACT);\n        return res_poly;\n    }\n\n    /**\n     * Intersect two polygons and returns new polygon\n     * Point belongs to the resultes polygon is it belongs to the first AND to the second polygon\n     * @param {Flatten.Polygon} polygon1 - first operand\n     * @param {Flatten.Polygon} polygon2 - second operand\n     * @returns {Flatten.Polygon}\n     */\n    static intersect(polygon1, polygon2) {\n        let res_poly = BooleanOp.booleanOpBinary(polygon1, polygon2, Flatten.BOOLEAN_INTERSECT);\n        return res_poly;\n    }\n\n    static arrange(polygon1, polygon2) {\n        // get intersection points\n        let intersections = BooleanOp.getIntersections(polygon1, polygon2);\n\n        // sort intersection points\n        BooleanOp.sortIntersections(intersections);\n\n        // split by intersection points\n        BooleanOp.splitByIntersections(polygon1, intersections.int_points1_sorted);\n        BooleanOp.splitByIntersections(polygon2, intersections.int_points2_sorted);\n    }\n\n    static clip(polygon1, polygon2, op) {\n        let res_poly = polygon1.clone();\n        let wrk_poly = polygon2.clone();\n\n        // get intersection points\n        let intersections = BooleanOp.getIntersections(res_poly, wrk_poly);\n\n        // sort intersection points\n        BooleanOp.sortIntersections(intersections);\n\n        // split by intersection points\n        BooleanOp.splitByIntersections(res_poly, intersections.int_points1_sorted);\n        BooleanOp.splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n        // filter duplicated intersection points\n        BooleanOp.filterDuplicatedIntersections(intersections);\n\n        // remove not relevant not intersected faces from res_polygon\n        // if op == UNION, remove faces that are included in wrk_polygon without intersection\n        // if op == INTERSECT, remove faces that are not included into wrk_polygon\n        BooleanOp.removeNotRelevantNotIntersectedFaces(res_poly, wrk_poly, op, intersections.int_points1, true);\n        BooleanOp.removeNotRelevantNotIntersectedFaces(wrk_poly, res_poly, op, intersections.int_points2, false);\n\n        // initialize inclusion flags for edges incident to intersections\n        BooleanOp.initializeInclusionFlags(intersections.int_points1);\n        BooleanOp.initializeInclusionFlags(intersections.int_points2);\n\n        // calculate inclusion flags only for edges incident to intersections\n        BooleanOp.calculateInclusionFlags(intersections.int_points1, polygon2);\n        BooleanOp.calculateInclusionFlags(intersections.int_points2, polygon1);\n\n        // TODO: fix bondary conflicts\n\n        // Set overlapping flags for boundary chains: SAME or OPPOSITE\n        BooleanOp.setOverlappingFlags(intersections);\n\n        // remove not relevant chains between intersection points\n        BooleanOp.removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n        BooleanOp.removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n        // add edges of wrk_poly into the edge container of res_poly\n        BooleanOp.copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n        // swap links from res_poly to wrk_poly and vice versa\n        BooleanOp.swapLinks(res_poly, wrk_poly, intersections);\n\n        // remove old faces\n        BooleanOp.removeOldFaces(res_poly, intersections.int_points1);\n        BooleanOp.removeOldFaces(wrk_poly, intersections.int_points2);\n\n        // restore faces\n        BooleanOp.restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n        BooleanOp.restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n        return res_poly;\n    }\n\n    static getIntersections(polygon1, polygon2) {\n        let intersections = {\n            int_points1: [],\n            int_points2: []\n        };\n\n        // calculate intersections\n        for (let edge1 of polygon1.edges) {\n\n            // request edges of polygon2 in the box of edge1\n            let resp = polygon2.edges.search(edge1.box);\n\n            // for each edge2 in response\n            for (let edge2 of resp) {\n\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n\n                // for each intersection point\n                for (let pt of ip) {\n                    BooleanOp.addToIntPoints(edge1, pt, intersections.int_points1);\n                    BooleanOp.addToIntPoints(edge2, pt, intersections.int_points2);\n                }\n            }\n        }\n        return intersections;\n    }\n\n    static addToIntPoints(edge, pt, int_points) {\n        let id = int_points.length;\n        let split = edge.shape.split(pt);\n        if (split.length === 0) return;     // Means point does not belong to edge\n        let len = 0;\n        if (split.length === 1) {           // Edge was not split\n            if (edge.shape.start.equalTo(pt)) {\n                len = 0;\n            }\n            else if (edge.shape.end.equalTo(pt)) {\n                len = edge.shape.length;\n            }\n        }\n        else {                             // Edge was split into to edges\n            len = split[0].length;\n        }\n        let is_vertex = NOT_VERTEX;\n        if (Flatten.Utils.EQ(len, 0)) {\n            is_vertex |= START_VERTEX;\n        }\n        if (Flatten.Utils.EQ(len, edge.shape.length)) {\n            is_vertex |= END_VERTEX;\n        }\n        // Fix intersection point which is end point of the last edge\n        let arc_length = (is_vertex & END_VERTEX) && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\n\n        int_points.push({\n            id: id,\n            pt: pt,\n            arc_length: arc_length,\n            edge_before: edge,\n            edge_after: undefined,\n            face: edge.face,\n            is_vertex: is_vertex\n        });\n    }\n\n    static sortIntersections(intersections) {\n        if (intersections.int_points1.length === 0) return;\n\n        // augment intersections with new sorted arrays\n        // intersections.int_points1_sorted = intersections.int_points1.slice().sort(BooleanOp.compareFn);\n        // intersections.int_points2_sorted = intersections.int_points2.slice().sort(BooleanOp.compareFn);\n        intersections.int_points1_sorted = BooleanOp.getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = BooleanOp.getSortedArray(intersections.int_points2);\n    }\n\n    static getSortedArray(int_points) {\n        let faceMap = new Map;\n        let id = 0;\n        // Create integer id's for faces\n        for (let ip of int_points) {\n            if (!faceMap.has(ip.face)) {\n                faceMap.set(ip.face, id);\n                id++;\n            }\n        }\n        // Augment intersection points with face id's\n        for (let ip of int_points) {\n            ip.faceId = faceMap.get(ip.face);\n        }\n        // Clone and sort\n        let int_points_sorted = int_points.slice().sort(BooleanOp.compareFn);\n        return int_points_sorted;\n    }\n\n    static compareFn(ip1, ip2) {\n        // compare face id's\n        if (ip1.faceId < ip2.faceId) {\n            return -1;\n        }\n        if (ip1.faceId > ip2.faceId) {\n            return 1;\n        }\n        // same face - compare arc_length\n        if (Flatten.Utils.LT(ip1.arc_length, ip2.arc_length)) {\n            return -1;\n        }\n        if (Flatten.Utils.GT(ip1.arc_length, ip2.arc_length)) {\n            return 1;\n        }\n        return 0;\n    }\n\n    static splitByIntersections(polygon, int_points) {\n        let {Polygon, Segment, Arc} = Flatten;\n        if (!int_points) return;\n        for (let int_point of int_points) {\n            let edge = int_point.edge_before;\n\n            // recalculate vertex flag: it may be changed after previous split\n            if (edge.shape.start.equalTo(int_point.pt)) {\n                int_point.is_vertex |= START_VERTEX;\n            }\n            if (edge.shape.end.equalTo(int_point.pt)) {\n                int_point.is_vertex |= END_VERTEX;\n            }\n\n            if (int_point.is_vertex & START_VERTEX) {  // nothing to split\n                int_point.edge_before = edge.prev;\n                int_point.is_vertex = END_VERTEX;\n                continue;\n            }\n            if (int_point.is_vertex & END_VERTEX) {    // nothing to split\n                continue;\n            }\n\n            let newEdge = polygon.addVertex(int_point.pt, edge);\n            int_point.edge_before = newEdge;\n        }\n\n        for (let int_point of int_points) {\n            int_point.edge_after = int_point.edge_before.next;\n        }\n    }\n\n    static filterDuplicatedIntersections(intersections) {\n        if (intersections.int_points1.length < 2) return;\n\n        let do_squeeze = false;\n\n        let int_point_ref1 = intersections.int_points1_sorted[0];\n        let int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n        for (let i = 1; i < intersections.int_points1_sorted.length; i++) {\n            let int_point_cur1 = intersections.int_points1_sorted[i];\n\n            if (!Flatten.Utils.EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n                int_point_ref1 = int_point_cur1;\n                int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n                continue;\n            }\n\n            /* Same length: int_point_cur1->arc_len == int_point_ref1->arc_len */\n            /* Ensure this is intersection between same edges from the same face */\n            let int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n\n        int_point_ref2 = intersections.int_points2_sorted[0];\n        int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n        for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n            let int_point_cur2 = intersections.int_points2_sorted[i];\n\n            if (int_point_cur2.id == -1) continue;\n            /* already deleted */\n\n            if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\n                !(Flatten.Utils.EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\n                int_point_ref2 = int_point_cur2;\n                int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n                continue;\n            }\n\n            let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n\n        if (do_squeeze) {\n            intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\n            intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\n\n            // update id's\n            intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n            intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n\n            // re-create sorted\n            intersections.int_points1_sorted = [];\n            intersections.int_points2_sorted = [];\n            BooleanOp.sortIntersections(intersections);\n        }\n    }\n\n    static removeNotRelevantNotIntersectedFaces(poly1, poly2, op, int_points1, is_res_polygon) {\n        let toBeDeleted = [];\n        for (let face of poly1.faces) {\n            if (!int_points1.find((ip) => ip.face === face)) {\n                let rel = face.getRelation(poly2);\n                if (op === Flatten.BOOLEAN_UNION && rel === Flatten.INSIDE) {\n                    toBeDeleted.push(face);\n                }\n                else if (op === Flatten.BOOLEAN_SUBTRACT && rel === Flatten.INSIDE && is_res_polygon) {\n                    toBeDeleted.push(face);\n                }\n                else if (op === Flatten.BOOLEAN_INTERSECT && rel === Flatten.OUTSIDE) {\n                    toBeDeleted.push(face);\n                }\n            }\n        }\n        for (let i = 0; i < toBeDeleted.length; i++) {\n            poly1.deleteFace(toBeDeleted[i]);\n        }\n    }\n\n    static initializeInclusionFlags(int_points) {\n        for (let int_point of int_points) {\n            int_point.edge_before.bvStart = undefined;\n            int_point.edge_before.bvEnd = undefined;\n            int_point.edge_before.bv = undefined;\n            int_point.edge_before.overlap = undefined;\n\n            int_point.edge_after.bvStart = undefined;\n            int_point.edge_after.bvEnd = undefined;\n            int_point.edge_after.bv = undefined;\n            int_point.edge_after.overlap = undefined;\n        }\n\n        for (let int_point of int_points) {\n            int_point.edge_before.bvEnd = Flatten.BOUNDARY;\n            int_point.edge_after.bvStart = Flatten.BOUNDARY;\n        }\n    }\n\n    static calculateInclusionFlags(int_points, polygon) {\n        for (let int_point of int_points) {\n            int_point.edge_before.setInclusion(polygon);\n            int_point.edge_after.setInclusion(polygon);\n        }\n    }\n\n    static setOverlappingFlags(intersections) {\n        let cur_face = undefined;\n        let first_int_point_in_face = undefined;\n        let next_int_point1 = undefined;\n        let num_int_points = intersections.int_points1.length;\n\n        for (let i = 0; i < num_int_points; i++) {\n            let cur_int_point1 = intersections.int_points1_sorted[i];\n\n            // Find boundary chain in the polygon1\n            if (cur_int_point1.face !== cur_face) {                               // next chain started\n                first_int_point_in_face = cur_int_point1;\n                cur_face = cur_int_point1.face;\n            }\n\n            if (i + 1 === num_int_points) {                                         // last int point in array\n                next_int_point1 = first_int_point_in_face;\n            }\n            else if (intersections.int_points1_sorted[i + 1].face !== cur_face) {   // last int point in chain\n                next_int_point1 = first_int_point_in_face;\n            }\n            else {                                                                // not a last point in chain\n                next_int_point1 = intersections.int_points1_sorted[i + 1];\n            }\n\n            let edge_from1 = cur_int_point1.edge_after;\n            let edge_to1 = next_int_point1.edge_before;\n\n            if (!(edge_from1.bv === Flatten.BOUNDARY && edge_to1.bv === Flatten.BOUNDARY))      // not a boundary chain - skip\n                continue;\n\n            if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\n                continue;\n\n\n            /* Find boundary chain in polygon2 between same intersection points */\n            let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n            let next_int_point2 = intersections.int_points2[next_int_point1.id];\n\n            let edge_from2 = cur_int_point2.edge_after;\n            let edge_to2 = next_int_point2.edge_before;\n\n            /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n            /* check also that chain consist of one or two edges */\n            if (!(edge_from2.bv === Flatten.BOUNDARY && edge_to2.bv === Flatten.BOUNDARY && edge_from2 === edge_to2)) {\n                cur_int_point2 = intersections.int_points2[next_int_point1.id];\n                next_int_point2 = intersections.int_points2[cur_int_point1.id];\n\n                edge_from2 = cur_int_point2.edge_after;\n                edge_to2 = next_int_point2.edge_before;\n            }\n\n            if (!(edge_from2.bv === Flatten.BOUNDARY && edge_to2.bv === Flatten.BOUNDARY && edge_from2 === edge_to2))\n                continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\n\n            // Set overlapping flag - one-to-one case\n            edge_from1.setOverlap(edge_from2);\n        }\n    }\n/*\n    static removeNotRelevantChains(polygon, op, int_points, is_res_polygon) {\n        if (!int_points) return;\n        for (let i = 0; i < int_points.length; i++) {\n            // TODO: Support claster of duplicated points with same <x,y> came from different faces\n\n            let int_point_current = int_points[i];\n            // Get next int point from the same face that current\n            let int_point_next;\n            if (i < int_points.length - 1 && int_points[i + 1].face === int_point_current.face) {\n                int_point_next = int_points[i + 1];   // get next point from same face\n            }\n            else {                                  // get first point from the same face\n                for (int_point_next of int_points) {\n                    if (int_point_next.face === int_point_current.face) {\n                        break;\n                    }\n                }\n            }\n\n            let edge_from = int_point_current.edge_after;\n            let edge_to = int_point_next.edge_before;\n\n            let face = int_point_current.face;\n\n            if ((edge_from.bv === Flatten.INSIDE && edge_to.bv === Flatten.INSIDE && op === Flatten.BOOLEAN_UNION) ||\n                (edge_from.bv === Flatten.OUTSIDE && edge_to.bv === Flatten.OUTSIDE && op === Flatten.BOOLEAN_INTERSECT) ||\n                ((edge_from.bv === Flatten.OUTSIDE || edge_to.bv === Flatten.OUTSIDE) && op === Flatten.BOOLEAN_SUBTRACT && !is_res_polygon) ||\n                ((edge_from.bv === Flatten.INSIDE || edge_to.bv === Flatten.INSIDE) && op === Flatten.BOOLEAN_SUBTRACT && is_res_polygon) ||\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_SAME) && is_res_polygon) ||\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_OPPOSITE) )) {\n\n                polygon.removeChain(face, edge_from, edge_to);\n\n                int_point_current.edge_after = undefined;\n                int_point_next.edge_before = undefined;\n            }\n        }\n    };\n*/\n    static removeNotRelevantChains(polygon, op, int_points, is_res_polygon) {\n        if (!int_points) return;\n        let cur_face = undefined;\n        let first_int_point_in_face_num = undefined;\n        let int_point_current;\n        let int_point_next;\n\n        for (let i = 0; i < int_points.length; i++) {\n            int_point_current = int_points[i];\n\n            if (int_point_current.face !== cur_face) {   // next face started\n                first_int_point_in_face_num = i;\n                cur_face = int_point_current.face;\n            }\n\n            if (cur_face.isEmpty())                // ??\n                continue;\n\n            // Get next int point from the same face that current\n\n            // Count how many duplicated points with same <x,y> in \"points from\" pull ?\n            let int_points_from_pull_start = i;\n            let int_points_from_pull_num = BooleanOp.intPointsPullCount(int_points, i, cur_face);\n            let next_int_point_num;\n            if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\n                int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n                next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n            }\n            else {                                         // get first point from the same face\n                next_int_point_num = first_int_point_in_face_num;\n            }\n            int_point_next = int_points[next_int_point_num];\n\n            /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n            let int_points_to_pull_start = next_int_point_num;\n            let int_points_to_pull_num = BooleanOp.intPointsPullCount(int_points, int_points_to_pull_start, cur_face);\n\n\n            let edge_from = int_point_current.edge_after;\n            let edge_to = int_point_next.edge_before;\n\n            if ((edge_from.bv === Flatten.INSIDE && edge_to.bv === Flatten.INSIDE && op === Flatten.BOOLEAN_UNION) ||\n                (edge_from.bv === Flatten.OUTSIDE && edge_to.bv === Flatten.OUTSIDE && op === Flatten.BOOLEAN_INTERSECT) ||\n                ((edge_from.bv === Flatten.OUTSIDE || edge_to.bv === Flatten.OUTSIDE) && op === Flatten.BOOLEAN_SUBTRACT && !is_res_polygon) ||\n                ((edge_from.bv === Flatten.INSIDE || edge_to.bv === Flatten.INSIDE) && op === Flatten.BOOLEAN_SUBTRACT && is_res_polygon) ||\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_SAME) && is_res_polygon) ||\n                (edge_from.bv === Flatten.BOUNDARY && edge_to.bv === Flatten.BOUNDARY && (edge_from.overlap & Flatten.OVERLAP_OPPOSITE))) {\n\n                polygon.removeChain(cur_face, edge_from, edge_to);\n\n                /* update all points in \"points from\" pull */\n                for (let k=int_points_from_pull_start; k < int_points_from_pull_start+int_points_from_pull_num; k++) {\n                    int_point_current.edge_after = undefined;\n                }\n\n                /* update all points in \"points to\" pull */\n                for (let k=int_points_to_pull_start; k < int_points_to_pull_start+int_points_to_pull_num; k++) {\n                    int_point_next.edge_before = undefined;\n                }\n            }\n\n            /* skip to the last point in \"points from\" group */\n            i += int_points_from_pull_num-1;\n        }\n    };\n\n    static intPointsPullCount(int_points, cur_int_point_num, cur_face) {\n        let int_point_current;\n        let int_point_next;\n\n        let int_points_pull_num = 1;\n\n        if (int_points.length == 1) return 1;\n\n        int_point_current = int_points[cur_int_point_num];\n\n        for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n            if (int_point_current.face != cur_face) {      /* next face started */\n                break;\n            }\n\n            int_point_next = int_points[i];\n\n            if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\n                int_point_next.edge_before === int_point_current.edge_before &&\n                int_point_next.edge_after === int_point_current.edge_after)) {\n                break;         /* next point is different - break and exit */\n            }\n\n            int_points_pull_num++;     /* duplicated intersection point - increase counter */\n        }\n        return int_points_pull_num;\n    }\n\n    static copyWrkToRes(res_polygon, wrk_polygon, op, int_points) {\n        for (let face of wrk_polygon.faces) {\n            for (let edge of face) {\n                res_polygon.edges.add(edge);\n            }\n            // If union - add face from wrk_polygon that is not intersected with res_polygon\n            if (op === Flatten.BOOLEAN_UNION &&\n                int_points && int_points.find((ip) => (ip.face === face)) === undefined) {\n                res_polygon.addFace(face.first, face.last);\n            }\n        }\n    }\n\n    static swapLinks(res_polygon, wrk_polygon, intersections) {\n        if (intersections.int_points1.length === 0) return;\n\n        for (let i = 0; i < intersections.int_points1.length; i++) {\n            let int_point1 = intersections.int_points1[i];\n            let int_point2 = intersections.int_points2[i];\n\n            // Simple case - find continuation on the other polygon\n\n            // Process edge from res_polygon\n            if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\n                if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\n                    // Connect edges\n                    int_point1.edge_before.next = int_point2.edge_after;\n                    int_point2.edge_after.prev = int_point1.edge_before;\n\n                    // Fill in missed links in intersection points\n                    int_point1.edge_after = int_point2.edge_after;\n                    int_point2.edge_before = int_point1.edge_before;\n                }\n            }\n            // Process edge from wrk_polygon\n            if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\n                if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\n                    // Connect edges\n                    int_point2.edge_before.next = int_point1.edge_after;\n                    int_point1.edge_after.prev = int_point2.edge_before;\n\n                    // Complete missed links\n                    int_point2.edge_after = int_point1.edge_after;\n                    int_point1.edge_before = int_point2.edge_before;\n                }\n            }\n\n            // Continuation not found - complex case\n            // Continuation will be found on the same polygon.\n            // It happens when intersection point is actually touching point\n            // Polygon1\n            if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\n                for (let int_point of intersections.int_points1_sorted) {\n                    if (int_point === int_point1) continue;     // skip same\n                    if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                        if (int_point.pt.equalTo(int_point1.pt)) {\n                            // Connect edges\n                            int_point1.edge_before.next = int_point.edge_after;\n                            int_point.edge_after.prev = int_point1.edge_before;\n\n                            // Complete missed links\n                            int_point1.edge_after = int_point.edge_after;\n                            int_point.edge_before = int_point1.edge_before;\n                        }\n                    }\n                }\n            }\n            // Polygon2\n            if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\n                for (let int_point of intersections.int_points2_sorted) {\n                    if (int_point === int_point2) continue;     // skip same\n                    if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                        if (int_point.pt.equalTo(int_point2.pt)) {\n                            // Connect edges\n                            int_point2.edge_before.next = int_point.edge_after;\n                            int_point.edge_after.prev = int_point2.edge_before;\n\n                            // Complete missed links\n                            int_point2.edge_after = int_point.edge_after;\n                            int_point.edge_before = int_point2.edge_before;\n                        }\n                    }\n                }\n            }\n        }\n        // Sanity check that no dead ends left\n    }\n\n    static removeOldFaces(polygon, int_points) {\n        for (let int_point of int_points) {\n            polygon.faces.delete(int_point.face);\n            int_point.face = undefined;\n            if (int_point.edge_before)\n                int_point.edge_before.face = undefined;\n            if (int_point.edge_after)\n                int_point.edge_after.face = undefined;\n        }\n    }\n\n    static restoreFaces(polygon, int_points, other_int_points) {\n        // For each intersection point - create new face\n        for (let int_point of int_points) {\n            if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\n                continue;\n            if (int_point.face)            // already restored\n                continue;\n\n            if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\n                continue;\n\n            let first = int_point.edge_after;      // face start\n            let last = int_point.edge_before;      // face end;\n\n            let face = polygon.addFace(first, last);\n\n            // Mark intersection points from the newly create face\n            // to avoid multiple creation of the same face\n            // Face was assigned to each edge of new face in addFace function\n            for (let int_point_tmp of int_points) {\n                if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                    int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                    int_point_tmp.face = face;\n                }\n            }\n            // Mark other intersection points as well\n            for (let int_point_tmp of other_int_points) {\n                if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                    int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                    int_point_tmp.face = face;\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = BooleanOp;","\"use strict\";\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;\r\n\r\n    let {vector} = Flatten;\r\n\r\n    Flatten.Distance = class Distance {\r\n        /**\r\n         * Calculate distance and shortest segment between points\r\n         * @param pt1\r\n         * @param pt2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2point(pt1, pt2) {\r\n            return pt1.distanceTo(pt2);\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and line\r\n         * @param pt\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2line(pt, line) {\r\n            let closest_point = pt.projectionOn(line);\r\n            let vec = vector(pt, closest_point);\r\n            return [vec.length, new Segment(pt, closest_point)];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and circle\r\n         * @param pt\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2circle(pt, circle) {\r\n            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n            if (Flatten.Utils.EQ_0(dist2center)) {\r\n                return [circle.r, new Segment(pt, circle.toArc().start)];\r\n            }\r\n            else {\r\n                let dist = Math.abs(dist2center - circle.r);\r\n                let v = vector(circle.pc, pt).normalize().multiply(circle.r);\r\n                let closest_point = circle.pc.translate(v);\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and segment\r\n         * @param pt\r\n         * @param segment\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2segment(pt, segment) {\r\n            /* Degenerated case of zero-length segment */\r\n            if (segment.start.equalTo(segment.end)) {\r\n                return  Distance.point2point(pt, segment.start);\r\n            }\r\n\r\n            let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n            let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n            let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n            let start_sp = v_seg.dot(v_ps2pt);\r\n            /* dot product v_seg * v_ps2pt */\r\n            let end_sp = -v_seg.dot(v_pe2pt);\r\n            /* minus dot product v_seg * v_pe2pt */\r\n\r\n            let dist;\r\n            let closest_point;\r\n            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n                /* unit vector ||v_unit|| = 1 */\r\n                dist = Math.abs(v_unit.cross(v_ps2pt));\r\n                /* dist = abs(v_unit x v_ps2pt) */\r\n                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n            else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n                return pt.distanceTo(segment.start);\r\n            }\r\n            else {                                               /* point is out of scope closer to pe */\r\n                return pt.distanceTo(segment.end);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and arc\r\n         * @param pt\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2arc(pt, arc) {\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let dist_and_segments = [];\r\n            let dist, shortest_segment;\r\n            [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n            if (shortest_segment.end.on(arc)) {\r\n                dist_and_segments.push(Distance.point2circle(pt, circle));\r\n            }\r\n            dist_and_segments.push( Distance.point2point(pt, arc.start) );\r\n            dist_and_segments.push( Distance.point2point(pt, arc.end) );\r\n\r\n            Distance.sort(dist_and_segments);\r\n\r\n            return dist_and_segments[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and line\r\n         * @param seg\r\n         * @param line\r\n         * @returns {Number | Segment}\r\n         */\r\n        static segment2line(seg, line) {\r\n            let ip = seg.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n\r\n            dist_and_segment.push(Distance.point2line(seg.start, line));\r\n            dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two segments\r\n         * @param seg1\r\n         * @param seg2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2segment(seg1, seg2) {\r\n            let ip = Segment.intersectSegment2Segment(seg1, seg2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n\r\n            // Seg1 and seg2 not intersected\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and circle\r\n         * @param seg\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2circle(seg, circle) {\r\n            /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(circle);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and circle\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius\r\n             * And projection point belong to segment\r\n              * Then measure again distance from projection to circle and return it */\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n                return Distance.point2circle(shortest_segment.end, circle);\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            else {\r\n                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                    [dist_from_start, shortest_segment_from_start] :\r\n                    [dist_from_end, shortest_segment_from_end];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and arc\r\n         * @param seg\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2arc(seg, arc) {\r\n            /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and arc\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n            dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n            let dist_tmp, segment_tmp;\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle1\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2circle(circle1, circle2) {\r\n            let ip = circle1.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n            if (circle1.center.equalTo(circle2.center)) {\r\n                let arc1 = circle1.toArc();\r\n                let arc2 = circle2.toArc();\r\n                return Distance.point2point(arc1.start, arc2.start);\r\n            }\r\n            else {\r\n                // Case 2. Not concentric circles\r\n                let line = new Line(circle1.center, circle2.center);\r\n                let ip1 = line.intersect(circle1);\r\n                let ip2 = line.intersect(circle2);\r\n\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2line(circle, line) {\r\n            let ip = circle.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and line\r\n         * @param arc\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2line(arc, line) {\r\n            /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n            let ip = line.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n                dist_and_segment.push( Distance.point2line(arc.start, line) );\r\n                dist_and_segment.push( Distance.point2line(arc.end, line) );\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and circle\r\n         * @param arc\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2circle(arc, circle2) {\r\n            let ip = arc.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n                dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two arcs\r\n         * @param arc1\r\n         * @param arc2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2arc(arc1, arc2) {\r\n            let ip = arc1.intersect(arc2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                let dist_tmp, segment_tmp;\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and polygon\r\n         * @param point\r\n         * @param polygon\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2polygon(point, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?\r\n                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static shape2polygon(shape, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n/*\r\n        static arc2polygon(arc, polygon) {\r\n            let ip = arc.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = arc.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static line2polygon(line, polygon) {\r\n            let ip = line.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = line.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static circle2polygon(circle, polygon) {\r\n            let ip = circle.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = circle.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n*/\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two polygons\r\n         * @param polygon1\r\n         * @param polygon2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static polygon2polygon(polygon1, polygon2) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let edge2 of polygon2.edges) {\r\n                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        /**\r\n         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n         * Minimal distance by x is\r\n         *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n         *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n         *    0,                       if box1 and box2 are intersected by x\r\n         * Minimal distance by y is defined in the same way\r\n         *\r\n         * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n         *\r\n         * @param box1\r\n         * @param box2\r\n         * @returns {Number | Number} - minimal and maximal distance\r\n         */\r\n        static box2box_minmax(box1, box2) {\r\n            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );\r\n            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );\r\n            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;\r\n\r\n            let box = box1.merge(box2);\r\n            let dx = box.xmax - box.xmin;\r\n            let dy = box.ymax - box.ymin;\r\n            let maxdist = dx*dx + dy*dy;\r\n\r\n            return [mindist, maxdist];\r\n        }\r\n\r\n        static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n            // Calculate minmax distance to each shape in current level\r\n            // Insert result into the interval tree for further processing\r\n            // update min_stop with maxdist, it will be the new stop distance\r\n            let mindist, maxdist;\r\n            for (let node of level) {\r\n\r\n                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                // if (Flatten.Utils.GT(mindist, min_stop))\r\n                //     continue;\r\n\r\n                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n                if (node.item.value instanceof Flatten.Edge) {\r\n                    tree.insert([mindist, maxdist], node.item.value.shape);\r\n                }\r\n                else {\r\n                    tree.insert([mindist, maxdist], node.item.value);\r\n                }\r\n                if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                    min_stop = maxdist;                       // this will be the new distance estimation\r\n                }\r\n            }\r\n\r\n            if (level.length === 0)\r\n                return min_stop;\r\n\r\n            // Calculate new level from left and right children of the current\r\n            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);\r\n            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n            // Merge left and right subtrees and leave only relevant subtrees\r\n            let new_level = [...new_level_left, ...new_level_right].filter( node => {\r\n                // Node subtree quick reject, node.max is a subtree box\r\n                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                return (Flatten.Utils.LE(mindist, min_stop));\r\n            });\r\n\r\n            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n            return min_stop;\r\n        }\r\n\r\n        /**\r\n         * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n         * and shapes of the planar set.\r\n         * @param shape\r\n         * @param set\r\n         */\r\n        static minmax_tree(shape, set, min_stop) {\r\n            let tree = new IntervalTree();\r\n            let level = [set.index.root];\r\n            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;\r\n            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n            return tree;\r\n        }\r\n\r\n        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n            let min_dist_and_segment_new, stop;\r\n            if (node != null && !node.isNil()) {\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n                if (stop) {\r\n                    return [min_dist_and_segment_new, stop];\r\n                }\r\n\r\n                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                    return [min_dist_and_segment_new, true];   // stop condition\r\n                }\r\n\r\n                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n                // console.log(dist)\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                    min_dist_and_segment_new = [dist, shortest_segment];\r\n                }\r\n\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            return [min_dist_and_segment, false];\r\n        }\r\n\r\n        /**\r\n         * Calculates distance between shape and Planar Set of shapes\r\n         * @param shape\r\n         * @param {PlanarSet} set\r\n         * @param {Number} min_stop\r\n         * @returns {*}\r\n         */\r\n        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n            let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n            let stop = false;\r\n            if (set instanceof Flatten.PlanarSet) {\r\n                let tree = Distance.minmax_tree(shape, set, min_stop);\r\n                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static sort(dist_and_segment) {\r\n            dist_and_segment.sort((d1, d2) => {\r\n                if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                    return -1;\r\n                }\r\n                if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        static distance(shape1, shape2) {\r\n            return shape1.distanceTo(shape2);\r\n        }\r\n    }\r\n};","/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Edge, Face, PlanarSet, Box} = Flatten;\r\n    let {ray_shoot} = Flatten;\r\n    /**\r\n     * Class representing a polygon.<br/>\r\n     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n     * @type {Polygon}\r\n     */\r\n    Flatten.Polygon = class Polygon {\r\n        /**\r\n         * Constructor creates new instance of polygon.<br/>\r\n         * New polygon is empty. Add face to the polygon using method <br/>\r\n         * <code>\r\n         *     polygon.addFace(Points[]|Segments[]|Arcs[])\r\n         * </code>\r\n         */\r\n        constructor() {\r\n            /**\r\n             * Container of faces (closed loops), may be empty\r\n             * @type {PlanarSet}\r\n             */\r\n            this.faces = new PlanarSet();\r\n            /**\r\n             * Container of edges\r\n             * @type {PlanarSet}\r\n             */\r\n            this.edges = new PlanarSet();\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns bounding box of the polygon\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns array of vertices\r\n         * @returns {Array}\r\n         */\r\n        get vertices() {\r\n            return [...this.edges].map( edge => edge.start);\r\n        }\r\n\r\n        /**\r\n         * Add new face to polygon. Returns added face\r\n         * @param {Points[]|Segments[]|Arcs[]} args - list of points or list of shapes (segments and arcs)\r\n         * which comprise a closed loop\r\n         * @returns {Face}\r\n         */\r\n        addFace(...args) {\r\n            let face = new Face(this, ...args);\r\n            this.faces.add(face);\r\n            return face;\r\n        }\r\n\r\n        /**\r\n         * Delete existing face from polygon\r\n         * @param {Face} face Face to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        deleteFace(face) {\r\n            for (let edge of face) {\r\n                let deleted = this.edges.delete(edge);\r\n            }\r\n            let deleted = this.faces.delete(face);\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Delete chain of edges from the face.\r\n         * @param {Face} face Face to remove chain\r\n         * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n         * @param {Edge} edgeTo End of the chain of edges to be removed\r\n         */\r\n        removeChain(face, edgeFrom, edgeTo) {\r\n            // Special case: all edges removed\r\n            if (edgeTo.next === edgeFrom) {\r\n                this.deleteFace(face);\r\n                return;\r\n            }\r\n            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {\r\n                face.remove(this.edges, edge);\r\n                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n                if (face.isEmpty()) {\r\n                    this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n         * When edge is split, new edge created from the start of the edge to the new vertex\r\n         * and inserted before current edge.\r\n         * Current edge is trimmed and updated. Method returns new edge added.\r\n         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n         * @param {Point} pt Point to be added as a new vertex\r\n         * @returns {Edge}\r\n         */\r\n        addVertex(pt, edge) {\r\n            let shapes = edge.shape.split(pt);\r\n            if (shapes.length < 2) return;\r\n            let newEdge = new Flatten.Edge(shapes[0]);\r\n            let edgeBefore = edge.prev;\r\n\r\n            /* Insert first split edge into linked list after edgeBefore */\r\n            edge.face.insert(this.edges, newEdge, edgeBefore);\r\n\r\n            // Remove old edge from edges container and 2d index\r\n            this.edges.delete(edge);\r\n\r\n            // Update edge shape with second split edge keeping links\r\n            edge.shape = shapes[1];\r\n\r\n            // Add updated edge to the edges container and 2d index\r\n            this.edges.add(edge);\r\n\r\n            return newEdge;\r\n        }\r\n\r\n        reverse() {\r\n            for (let face of this.faces) {\r\n                face.reverse();\r\n            }\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Create new copied instance of the polygon\r\n         * @returns {Polygon}\r\n         */\r\n        clone() {\r\n            let polygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.clone());\r\n                }\r\n                polygon.addFace(shapes);\r\n            }\r\n            return polygon;\r\n        }\r\n\r\n        /**\r\n         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);\r\n            return Math.abs(signedArea);\r\n        }\r\n\r\n        /**\r\n         * Returns true if polygon contains point, including polygon boundary, false otherwise\r\n         * Point in polygon test based on ray shooting algorithm\r\n         * @param {Point} point - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(point) {\r\n            let rel = ray_shoot(this, point);\r\n            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;\r\n        }\r\n\r\n        /**\r\n         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n         * @returns {Number | Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            /* this method is bit faster */\r\n            if (shape instanceof  Flatten.Polygon) {\r\n                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n                let dist, shortest_segment;\r\n\r\n                for (let edge of this.edges) {\r\n                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                    let min_stop = min_dist_and_segment[0];\r\n                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                    if (Flatten.Utils.LT(dist, min_stop)) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n                return min_dist_and_segment;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return true if polygon is valid for boolean operations\r\n         * Polygon is valid if <br/>\r\n         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n         * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n         * @returns {boolean}\r\n         */\r\n        isValid() {\r\n            let valid = true;\r\n            // 1. Polygon is invalid if at least one face is not simple\r\n            for (let face of this.faces) {\r\n                if (!face.isSimple(this.edges)) {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n            // 2. TODO: check if no island inside island and no hole inside hole\r\n            // 3. TODO: check the there is no intersection between faces\r\n            return valid;\r\n        }\r\n\r\n        /**\r\n         * Returns new polygon translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Polygon}\r\n         */\r\n        translate(vec) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.translate(vec));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw polygon in svg\r\n         * @param attrs  - json structure with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\"\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n            for (let face of this.faces) {\r\n                svgStr += face.svg();\r\n            }\r\n            svgStr += `\" >\\n</path>`;\r\n\r\n            return svgStr;\r\n        }\r\n\r\n        toJSON() {\r\n            return [...this.faces].map(face => face.toJSON());\r\n        }\r\n    }\r\n};","\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;\r\n\r\n    Flatten.ray_shoot = function(polygon, point) {\r\n        let contains = undefined;\r\n\r\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\r\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        // }\r\n\r\n        // 1. Quick reject\r\n        if (polygon.box.notIntersect(point.box)) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        let ray = new Ray(point);\r\n        let line = new Line(ray.pt, ray.norm);\r\n\r\n        // 2. Locate relevant edges of the polygon\r\n        let resp_edges = polygon.edges.search(ray.box);\r\n\r\n        if (resp_edges.length == 0) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        // 3. Calculate intersections\r\n        let intersections = [];\r\n        for (let edge of resp_edges) {\r\n            for (let ip of ray.intersect(edge.shape)) {\r\n\r\n                // If intersection is equal to query point then point lays on boundary\r\n                if (ip.equalTo(point)) {\r\n                    return Flatten.BOUNDARY;\r\n                }\r\n\r\n                intersections.push({\r\n                    pt: ip,\r\n                    edge: edge\r\n                });\r\n            }\r\n        }\r\n\r\n        // 4. Sort intersection in x-ascending order\r\n        intersections.sort( (i1, i2) => {\r\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n\r\n        // 5. Count real intersections, exclude touching\r\n        let counter = 0;\r\n\r\n        for (let i=0; i < intersections.length; i++) {\r\n            let intersection = intersections[i];\r\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.prev === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let prev_edge = intersection.edge.prev;\r\n                let prev_tangent = prev_edge.shape.tangentInEnd();\r\n                let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInStart();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let prev_on_the_left = prev_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.next === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let next_edge = intersection.edge.next;\r\n                let next_tangent = next_edge.shape.tangentInStart();\r\n                let next_point = intersection.pt.translate(next_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let next_on_the_left = next_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else {        /* intersection point is not a coincident with a vertex */\r\n                if (intersection.edge.shape instanceof Segment) {\r\n                    counter++;\r\n                }\r\n                else {\r\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                    let box = intersection.edge.shape.box;\r\n                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||\r\n                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {\r\n                        counter++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 6. Odd or even?\r\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\r\n\r\n        return contains;\r\n    };\r\n};","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;\r\n    /**\r\n     * Class representing a horizontal ray, used by ray shooting algorithm\r\n     * @type {Ray}\r\n     */\r\n    Flatten.Ray = class Ray {\r\n        /**\r\n         * Construct ray by setting start point\r\n         * @param {Point} pt - start point\r\n         */\r\n        constructor(...args) {\r\n            this.pt = new Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Point) {\r\n                this.pt = args[0].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                this.pt = new Point(args[0], args[1]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns copied instance of the ray object\r\n         * @returns {Ray}\r\n         */\r\n        clone() {\r\n            return new Ray(this.pt);\r\n        }\r\n\r\n        /**\r\n         * Returns half-infinite bounding box of the ray\r\n         * @returns {Box} - bounding box\r\n         */\r\n        get box() {\r\n            return new Box(\r\n                this.pt.x,\r\n                this.pt.y,\r\n                Number.POSITIVE_INFINITY,\r\n                this.pt.y\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Return ray start point\r\n         * @returns {Point} - ray start point\r\n         */\r\n        get start() {\r\n            return this.pt;\r\n        }\r\n\r\n        /**\r\n         * Return ray normal vector (0,1) - horizontal ray\r\n         * @returns {Vector} - ray normal vector\r\n         */\r\n        get norm() {\r\n            return new Vector(0,1);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between ray and segment or arc\r\n         * @param {Segment|Arc} - Shape to intersect with ray\r\n         * @returns {Array} array of intersection points\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Segment) {\r\n                return this.intersectRay2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Arc) {\r\n                return this.intersectRay2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        intersectRay2Segment(ray, segment) {\r\n            let ip = [];\r\n\r\n            if (ray.box.notIntersect(segment.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(segment);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            /* If there were two intersection points between line and ray,\r\n            and now there is exactly one left, it means ray starts between these points\r\n            and there is another intersection point - start of the ray */\r\n            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n                ip.push(ray.start);\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        intersectRay2Arc(ray, arc) {\r\n            let ip = [];\r\n\r\n            if (ray.box.notIntersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(arc);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    Flatten.ray = (...args) => new Flatten.Ray(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    let {Point, Segment, Arc, Box, Edge} = Flatten;\r\n    /**\r\n     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n     * Face object cannot be instantiated with a constructor.\r\n     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n     * <br/>\r\n     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n     * Container of edges is a property of the polygon object. <br/>\r\n     *\r\n     * @example\r\n     * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n     * for (let edge of face) {\r\n     *      console.log(edge.shape.length)     // do something\r\n     * }\r\n     *\r\n     * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n     * let edge = face.first;\r\n     * do {\r\n     *   console.log(edge.shape.length);   // do something\r\n     *   edge = edge.next;\r\n     * } while (edge != face.first)\r\n     */\r\n    Flatten.Face = class Face {\r\n        constructor(polygon, ...args) {\r\n            /**\r\n             * Reference to the first edge in face\r\n             */\r\n            this.first;\r\n            /**\r\n             * Reference to the last edge in face\r\n             */\r\n            this.last;\r\n\r\n            this._box = undefined;  // new Box();\r\n            this._orientation = undefined;\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            /* If passed an array it supposed to be:\r\n             1) array of shapes that performs close loop or\r\n             2) array of points that performs set of vertices\r\n             */\r\n            if (args.length == 1) {\r\n                if (args[0] instanceof Array) {\r\n                    // let argsArray = args[0];\r\n                    let shapes = args[0];  // argsArray[0];\r\n                    if (shapes.length == 0)\r\n                        return;\r\n\r\n                    if (shapes.every((shape) => {\r\n                            return shape instanceof Point\r\n                        })) {\r\n                        let segments = Face.points2segments(shapes);\r\n                        this.shapes2face(polygon.edges, segments);\r\n                    }\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape instanceof Segment || shape instanceof Arc)\r\n                        })) {\r\n                        this.shapes2face(polygon.edges, shapes);\r\n                    }\r\n                    // this is from JSON.parse object\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                        })) {\r\n                        let flattenShapes = [];\r\n                        for (let shape of shapes) {\r\n                            let flattenShape;\r\n                            if (shape.name === \"segment\") {\r\n                                flattenShape = new Segment(shape.ps.x, shape.ps.y, shape.pe.x, shape.pe.y);\r\n                            }\r\n                            else {\r\n                                flattenShape = new Arc(new Point(shape.pc.x, shape.pc.y),\r\n                                    shape.r, shape.startAngle, shape.endAngle, shape.counterClockwise);\r\n                            }\r\n                            flattenShapes.push(flattenShape);\r\n                        }\r\n                        this.shapes2face(polygon.edges, flattenShapes);\r\n                    }\r\n                }\r\n                /* Create new face and copy edges into polygon.edges set */\r\n                else if (args[0] instanceof Face) {\r\n                    let face = args[0];\r\n                    this.first = face.first;\r\n                    this.last = face.last;\r\n                    for (let edge of face) {\r\n                        polygon.edges.add(edge);\r\n                    }\r\n                }\r\n            }\r\n            /* If passed two edges, consider them as start and end of the face loop */\r\n            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {\r\n                this.first = args[0];                          // first edge in face or undefined\r\n                this.last = args[1];                           // last edge in face or undefined\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                this.setArcLength();\r\n                /*\r\n                 let edge = this.first;\r\n                 edge.arc_length = 0;\r\n                 edge = edge.next;\r\n                 while (edge !== this.first) {\r\n                 edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                 edge = edge.next;\r\n                 }\r\n                 */\r\n\r\n                // this.box = this.getBox();\r\n                // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n            }\r\n        }\r\n\r\n        [Symbol.iterator]() {\r\n            let edge = undefined;\r\n            return {\r\n                next: () => {\r\n                    let value = edge ? edge : this.first;\r\n                    let done = this.first ? (edge ? edge === this.first : false) : true;\r\n                    edge = value ? value.next : undefined;\r\n                    return {value: value, done: done};\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n         * Return array of edges from first to last\r\n         * @returns {Array}\r\n         */\r\n        get edges() {\r\n            let face_edges = [];\r\n            for (let edge of this) {\r\n                face_edges.push(edge);\r\n            }\r\n            return face_edges;\r\n        }\r\n\r\n        /**\r\n         * Return number of edges in the face\r\n         * @returns {number}\r\n         */\r\n        get size() {\r\n            let counter = 0;\r\n            for (let edge of this) {\r\n                counter++;\r\n            }\r\n            return counter;\r\n        }\r\n\r\n        static points2segments(points) {\r\n            let segments = [];\r\n            for (let i = 0; i < points.length; i++) {\r\n                segments.push(new Segment(points[i], points[(i + 1) % points.length]));\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        shapes2face(edges, shapes) {\r\n            for (let shape of shapes) {\r\n                let edge = new Edge(shape);\r\n                this.append(edges, edge);\r\n                // this.box = this.box.merge(shape.box);\r\n                // edges.add(edge);\r\n            }\r\n            // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n        }\r\n\r\n        /**\r\n         * Returns true if face is empty, false otherwise\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return (this.first === undefined && this.last === undefined)\r\n        }\r\n\r\n        /**\r\n         * Append given edge after the last edge (and before the first edge). <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be appended to the linked list\r\n         */\r\n        append(edges, edge) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n                edge.arc_length = 0;\r\n            }\r\n            else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n            }\r\n            edge.face = this;\r\n\r\n            edges.add(edge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} newEdge - Edge to be inserted into linked list\r\n         * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n         */\r\n        insert(edges, newEdge, edgeBefore) {\r\n            if (this.first === undefined) {\r\n                newEdge.prev = newEdge;\r\n                newEdge.next = newEdge;\r\n                this.first = newEdge;\r\n                this.last = newEdge;\r\n            }\r\n            else {\r\n                /* set links to new edge */\r\n                let edgeAfter = edgeBefore.next;\r\n                edgeBefore.next = newEdge;\r\n                edgeAfter.prev = newEdge;\r\n\r\n                /* set links from new edge */\r\n                newEdge.prev = edgeBefore;\r\n                newEdge.next = edgeAfter;\r\n\r\n                /* extend chain if new edge added after last edge */\r\n                if (this.last === edgeBefore)\r\n                    this.first = newEdge;\r\n            }\r\n            newEdge.face = this;\r\n\r\n            // set arc length\r\n            if (newEdge.prev === this.last) {\r\n                newEdge.arc_length = 0;\r\n            }\r\n            else {\r\n                newEdge.arc_length = newEdge.prev.arc_length + newEdge.prev.length;\r\n            }\r\n\r\n            edges.add(newEdge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Remove the given edge from the linked list of the face <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be removed\r\n         */\r\n        remove(edges, edge) {\r\n            // special case if last edge removed\r\n            if (edge === this.first && edge === this.last) {\r\n                this.first = undefined;\r\n                this.last = undefined;\r\n            }\r\n            else {\r\n                // update linked list\r\n                edge.prev.next = edge.next;\r\n                edge.next.prev = edge.prev;\r\n                // update first if need\r\n                if (edge === this.first) {\r\n                    this.first = edge.next;\r\n                }\r\n                // update last if need\r\n                if (edge === this.last) {\r\n                    this.last = edge.prev;\r\n                }\r\n            }\r\n            edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n        }\r\n\r\n        /**\r\n         * Reverse orientation of the face: first edge become last and vice a verse,\r\n         * all edges starts and ends swapped, direction of arcs inverted.\r\n         */\r\n        reverse() {\r\n            // collect edges in revert order with reverted shapes\r\n            let edges = [];\r\n            let edge_tmp = this.last;\r\n            do {\r\n                // reverse shape\r\n                edge_tmp.shape = edge_tmp.shape.reverse();\r\n                edges.push(edge_tmp);\r\n                edge_tmp = edge_tmp.prev;\r\n            } while (edge_tmp !== this.last);\r\n\r\n            // restore linked list\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n            for (let edge of edges) {\r\n                if (this.first === undefined) {\r\n                    edge.prev = edge;\r\n                    edge.next = edge;\r\n                    this.first = edge;\r\n                    this.last = edge;\r\n                    edge.arc_length = 0;\r\n                }\r\n                else {\r\n                    // append to end\r\n                    edge.prev = this.last;\r\n                    this.last.next = edge;\r\n\r\n                    // update edge to be last\r\n                    this.last = edge;\r\n\r\n                    // restore circular links\r\n                    this.last.next = this.first;\r\n                    this.first.prev = this.last;\r\n\r\n                    // set arc length\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n            }\r\n\r\n            // Recalculate orientation, if set\r\n            if (this._orientation !== undefined) {\r\n                this._orientation = undefined;\r\n                this._orientation = this.orientation();\r\n            }\r\n        }\r\n\r\n\r\n        /**\r\n         * Set arc_length property for each of the edges in the face.\r\n         * Arc_length of the edge it the arc length from the first edge of the face\r\n         */\r\n        setArcLength() {\r\n            for (let edge of this) {\r\n                if (edge === this.first) {\r\n                    edge.arc_length = 0.0;\r\n                }\r\n                else {\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n                edge.face = this;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the absolute value of the area of the face\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            return Math.abs(this.signedArea());\r\n        }\r\n\r\n        /**\r\n         * Returns signed area of the simple face.\r\n         * Face is simple if it has no self intersections that change its orientation.\r\n         * Then the area will be positive if the orientation of the face is clockwise,\r\n         * and negative if orientation is counterclockwise.\r\n         * It may be zero if polygon is degenerated.\r\n         * @returns {number}\r\n         */\r\n        signedArea() {\r\n            let sArea = 0;\r\n            for (let edge of this) {\r\n                sArea += edge.shape.definiteIntegral(this.box.ymin);\r\n            }\r\n            return sArea;\r\n        }\r\n\r\n        /**\r\n         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n         * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n         * and the sign of the integral will be defined by the direction of the curve.\r\n         * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n         * when positive - clockwise and when it is zero, polygon is not orientable.\r\n         * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n         * @returns {number}\r\n         */\r\n        orientation() {\r\n            if (this._orientation === undefined) {\r\n                let area = this.signedArea();\r\n                if (Flatten.Utils.EQ_0(area)) {\r\n                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n                }\r\n                else if (Flatten.Utils.LT(area, 0)) {\r\n                    this._orientation = Flatten.ORIENTATION.CCW;\r\n                }\r\n                else {\r\n                    this._orientation = Flatten.ORIENTATION.CW;\r\n                }\r\n            }\r\n            return this._orientation;\r\n        }\r\n\r\n        /**\r\n         * Return bounding box of the face\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            if (this._box === undefined) {\r\n                let box = new Flatten.Box();\r\n                for (let edge of this) {\r\n                    box = box.merge(edge.box);\r\n                }\r\n                this._box = box;\r\n            }\r\n            return this._box;\r\n        }\r\n\r\n        /**\r\n         * Check relation between face and other polygon\r\n         * on strong assumption that they are NOT INTERSECTED <br/>\r\n         * Then there are 4 options: <br/>\r\n         * face disjoint to polygon - Flatten.OUTSIDE <br/>\r\n         * face inside polygon - Flatten.INSIDE <br/>\r\n         * face contains polygon - Flatten.CONTAIN <br/>\r\n         * face interlaced with polygon: inside some face and contains other face - Flatten.INTERLACE <br/>\r\n         * @param {Polygon} polygon - Polygon to check relation\r\n         */\r\n        getRelation(polygon) {\r\n            this.first.bv = this.first.bvStart = this.first.bvEnd = undefined;\r\n            let bvThisInOther = this.first.setInclusion(polygon);\r\n            let resp = polygon.faces.search(this.box);\r\n            if (resp.length === 0) {\r\n                return bvThisInOther;        // OUTSIDE or INSIDE\r\n            }\r\n            else {                           // possible INTERLACE\r\n                let polyTmp = new Flatten.Polygon();\r\n                polyTmp.addFace(this);\r\n\r\n                let numInsideThis = 0;\r\n                for (let face of resp) {\r\n                    face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\r\n                    let bvOtherInThis = face.first.setInclusion(polyTmp);\r\n                    if (bvOtherInThis === Flatten.INSIDE) {\r\n                        numInsideThis++;\r\n                    }\r\n                }\r\n                if (bvThisInOther === Flatten.OUTSIDE) {\r\n                    if (numInsideThis === 0) {                   // none inside this - outside\r\n                        return Flatten.OUTSIDE;\r\n                    }\r\n                    else if (numInsideThis === resp.length) {      // all from resp inside this - contains or interlace\r\n                        if (resp.length === polygon.faces.size) {\r\n                            return Flatten.CONTAINS;               // all faces from polygon are in response - contains\r\n                        }\r\n                        else {\r\n                            return Flatten.INTERLACE;              // some faces inside - interlace\r\n                        }\r\n                    }\r\n                    else {\r\n                        return Flatten.INTERLACE;                  // some faces inside - interlace\r\n                    }\r\n                }\r\n                else if (bvThisInOther === Flatten.INSIDE) {\r\n                    return numInsideThis === 0 ? Flatten.INSIDE : Flatten.INTERLACE;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns true if face of the polygon is simple (no self-intersection points found)\r\n         * NOTE: this method is incomplete because it doe not exclude touching points\r\n         * Real self intersection inverts orientation of the polygon.\r\n         * But this is also good enough for the demonstration of the idea\r\n         * @param {Edges} edges - reference to polygon.edges to provide search index\r\n         * @returns {boolean}\r\n         */\r\n        isSimple(edges) {\r\n            let ip = Face.getSelfIntersections(this, edges, true);\r\n            return ip.length == 0;\r\n        }\r\n\r\n        static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n            let int_points = [];\r\n\r\n            // calculate intersections\r\n            for (let edge1 of face) {\r\n\r\n                // request edges of polygon in the box of edge1\r\n                let resp = edges.search(edge1.box);\r\n\r\n                // for each edge2 in response\r\n                for (let edge2 of resp) {\r\n\r\n                    // Skip itself\r\n                    if (edge1 === edge2)\r\n                        continue;\r\n\r\n                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                        (edge1.next === edge2 || edge1.prev === edge2))\r\n                        continue;\r\n\r\n                    // calculate intersections between edge1 and edge2\r\n                    let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                    // for each intersection point\r\n                    for (let pt of ip) {\r\n\r\n                        // skip start-end connections\r\n                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                            continue;\r\n                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                            continue;\r\n\r\n                        int_points.push(pt);\r\n\r\n                        if (exitOnFirst)\r\n                            break;\r\n                    }\r\n\r\n                    if (int_points.length > 0 && exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n\r\n            }\r\n            return int_points;\r\n        }\r\n\r\n        toJSON() {\r\n            return this.edges.map(edge => edge.toJSON());\r\n        }\r\n\r\n        svg() {\r\n            let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n\r\n            for (let edge of this) {\r\n                svgStr += edge.svg();\r\n            }\r\n\r\n            svgStr += ` z`;\r\n            return svgStr;\r\n        }\r\n\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n     * Each edge contains references to the next and previous edges in the face of the polygon.\r\n     *\r\n     * @type {Edge}\r\n     */\r\n    Flatten.Edge = class Edge {\r\n        /**\r\n         * Construct new instance of edge\r\n         * @param {Shape} shape Shape of type Segment of Arc\r\n         */\r\n        constructor(shape) {\r\n            /**\r\n             * Shape of the edge: Segment or Arc\r\n             */\r\n            this.shape = shape;\r\n            /**\r\n             * Pointer to the next edge in the face\r\n             */\r\n            this.next;\r\n            /**\r\n             * Pointer to the previous edge in the face\r\n             */\r\n            this.prev;\r\n            /**\r\n             * Pointer to the face containing this edge\r\n             * @type {Face}\r\n             */\r\n            this.face;\r\n            /**\r\n             * \"Arc distance\" from the face start\r\n             * @type {number}\r\n             */\r\n            this.arc_length = 0;\r\n            /**\r\n             * Start inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvStart = undefined;\r\n            /**\r\n             * End inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvEnd = undefined;\r\n            /**\r\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n             * @type {*}\r\n             */\r\n            this.bv = undefined;\r\n            /**\r\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n             * @type {*}\r\n             */\r\n            this.overlap = undefined;\r\n        }\r\n\r\n        /**\r\n         * Get edge start point\r\n         */\r\n        get start() {\r\n            return this.shape.start;\r\n        }\r\n\r\n        /**\r\n         * Get edge end point\r\n         */\r\n        get end() {\r\n            return this.shape.end;\r\n        }\r\n\r\n        /**\r\n         * Get edge length\r\n         */\r\n        get length() {\r\n            return this.shape.length;\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the edge\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return this.shape.box;\r\n        }\r\n\r\n        /**\r\n         * Get middle point of the edge\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return this.shape.middle();\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the edge, false otherwise\r\n         * @param {Point} pt - test point\r\n         */\r\n        contains(pt) {\r\n            return this.shape.contains(pt);\r\n        }\r\n\r\n        /**\r\n         * Set inclusion flag of the edge with respect to another polygon\r\n         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n         * @param polygon\r\n         */\r\n        setInclusion(polygon) {\r\n            if (this.bv !== undefined) return this.bv;\r\n\r\n            if (this.bvStart === undefined) {\r\n                this.bvStart = Flatten.ray_shoot(polygon, this.start);\r\n            }\r\n            if (this.bvEnd === undefined) {\r\n                this.bvEnd = Flatten.ray_shoot(polygon, this.end);\r\n            }\r\n            /* At least one end outside - the whole edge outside */\r\n            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n                this.bv = Flatten.OUTSIDE;\r\n            }\r\n            /* At least one end inside - the whole edge inside */\r\n            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n                this.bv = Flatten.INSIDE;\r\n            }\r\n            /* Both are boundary - check the middle point */\r\n            else {\r\n                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());\r\n                this.bv = bvMiddle;\r\n            }\r\n            return this.bv;\r\n        }\r\n\r\n        /**\r\n         * Set overlapping between two coincident boundary edges\r\n         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n         * @param edge\r\n         */\r\n        setOverlap(edge) {\r\n            let flag = undefined;\r\n            let shape1 = this.shape;\r\n            let shape2 = edge.shape;\r\n\r\n            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.counterClockwise === shape2.counterClockwise &&\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.counterClockwise !== shape2.counterClockwise &&\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n\r\n            /* Do not update overlap flag if already set on previous chain */\r\n            if (this.overlap === undefined) this.overlap = flag;\r\n            if (edge.overlap === undefined) edge.overlap = flag;\r\n        }\r\n\r\n        svg() {\r\n            if (this.shape instanceof Flatten.Segment) {\r\n                return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n            }\r\n            else if (this.shape instanceof  Flatten.Arc) {\r\n                let arc = this.shape;\r\n                let largeArcFlag;\r\n                let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n                // Draw full circe arc as special case: split it into two half-circles\r\n                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {\r\n                    let sign = arc.counterClockwise ? 1 : -1;\r\n                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);\r\n                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                    largeArcFlag = \"0\";\r\n\r\n                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n                }\r\n                else {\r\n                    largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        toJSON() {\r\n            let json = this.shape.clone();\r\n            // json.name = this.shape.constructor.name;          // not pass webpack minification\r\n            json.name = this.shape instanceof  Flatten.Segment ? \"segment\" : \"arc\";\r\n            return json;\r\n        }\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class Box represent bounding box of the shape\r\n     * @type {Box}\r\n     */\r\n    Flatten.Box = class Box {\r\n        /**\r\n         *\r\n         * @param {number} xmin - minimal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {\r\n            /**\r\n             * Minimal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmin = xmin;\r\n            /**\r\n             * Minimal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymin = ymin;\r\n            /**\r\n             * Maximal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmax = xmax;\r\n            /**\r\n             * Maximal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Clones and returns new instance of box\r\n         * @returns {Box}\r\n         */\r\n        clone() {\r\n            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property low need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get low() {\r\n            return new Flatten.Point(this.xmin, this.ymin);\r\n        }\r\n\r\n        /**\r\n         * Property high need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get high() {\r\n            return new Flatten.Point(this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property max returns the box itself !\r\n         * @returns {Box}\r\n         */\r\n        get max() {\r\n            return this.clone();\r\n        }\r\n\r\n        /**\r\n         * Returns true if not intersected with other box\r\n         * @param {Box} other_box - other box to test\r\n         * @returns {boolean}\r\n         */\r\n        notIntersect(other_box) {\r\n            return (\r\n                this.xmax < other_box.xmin ||\r\n                this.xmin > other_box.xmax ||\r\n                this.ymax < other_box.ymin ||\r\n                this.ymin > other_box.ymax\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns true if intersected with other box\r\n         * @param {Box} other_box - Query box\r\n         * @returns {boolean}\r\n         */\r\n        intersect(other_box) {\r\n            return !this.notIntersect(other_box);\r\n        }\r\n\r\n        /**\r\n         * Returns new box merged with other box\r\n         * @param {Box} other_box - Other box to merge with\r\n         * @returns {Box}\r\n         */\r\n        merge(other_box) {\r\n            return new Box(\r\n                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between two boxes. Need for interval index\r\n         * @param {Box} other_box - other box\r\n         * @returns {boolean} - true if this box less than other box, false otherwise\r\n         */\r\n        less_than(other_box) {\r\n            if (this.low.lessThan(other_box.low))\r\n                return true;\r\n            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns true if this box is equal to other box, false otherwise\r\n         * @param {Box} other_box - query box\r\n         * @returns {boolean}\r\n         */\r\n        equal_to(other_box) {\r\n            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n        }\r\n\r\n        output() {\r\n            return this.clone();\r\n        }\r\n\r\n        maximal_val(box1, box2) {\r\n            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n            return box1.merge(box2);\r\n        }\r\n\r\n        val_less_than(pt1, pt2) {\r\n            return pt1.lessThan(pt2);\r\n        }\r\n\r\n        /**\r\n         * Set new values to the box object\r\n         * @param {number} xmin - miminal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        set(xmin, ymin, xmax, ymax) {\r\n            this.xmin = xmin;\r\n            this.ymin = ymin;\r\n            this.xmax = xmax;\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - json structure with attributes of svg rectangle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            let width = this.xmax - this.xmin;\r\n            let height = this.ymax - this.ymin;\r\n\r\n            return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n        }\r\n    };\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a circular arc\r\n     * @type {Arc}\r\n     */\r\n    Flatten.Arc = class Arc {\r\n        /**\r\n         *\r\n         * @param {Point} pc - arc center\r\n         * @param {number} r - arc radius\r\n         * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n         * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n         * @param {boolean} counterClockwise - arc direction, true - clockwise (or {@link Flatten.CCW}), false - counter clockwise (or {@link Flatten.CW)}\r\n         */\r\n        constructor(pc=new Flatten.Point(), r=1, startAngle=0, endAngle=2*Math.PI, counterClockwise=true) {\r\n            this.pc = pc.clone();\r\n            this.r = r;\r\n            this.startAngle = startAngle;\r\n            this.endAngle = endAngle;\r\n            this.counterClockwise = counterClockwise;\r\n        }\r\n\r\n        /**\r\n         * Return new instance of arc\r\n         * @returns {Arc}\r\n         */\r\n        clone() {\r\n            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n         * @returns {number}\r\n         */\r\n        get sweep() {\r\n            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n                return 0.0;\r\n            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n                return Flatten.PIx2;\r\n            }\r\n            let sweep;\r\n            if (this.counterClockwise) {\r\n                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n            } else {\r\n                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n            }\r\n\r\n            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {\r\n                sweep -= Flatten.PIx2;\r\n            }\r\n            if ( Flatten.Utils.LT(sweep, 0) ) {\r\n                sweep += Flatten.PIx2;\r\n            }\r\n            return sweep;\r\n        }\r\n\r\n        /**\r\n         * Get start point of arc\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.startAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get end point of arc\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.endAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get center of arc\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc.clone();\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.start.clone(), this.end.clone()];\r\n        }\r\n\r\n        /**\r\n         * Get arc length\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.abs(this.sweep*this.r);\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the arc\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            let func_arcs = this.breakToFunctional();\r\n            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );\r\n            box = box.merge(this.end.box);\r\n            return box;\r\n        }\r\n\r\n        /**\r\n         * Returns true if arc contains point, false otherwise\r\n         * @param {Point} pt - point to test\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            // first check if  point on circle (pc,r)\r\n            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n                return false;\r\n\r\n            // point on circle\r\n\r\n            if (pt.equalTo(this.start))\r\n                return true;\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n            return Flatten.Utils.LE(test_arc.length, this.length);\r\n        }\r\n\r\n        /**\r\n         * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n         * empty array.\r\n         * @param {Point} pt Query point\r\n         * @returns {Arc[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (Flatten.Utils.EQ_0(this.sweep))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this.clone()];\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n            return [\r\n                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the arc\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            let endAngle = this.counterClockwise === Flatten.CCW ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;\r\n            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n            return arc.end;\r\n        }\r\n\r\n        /**\r\n         * Returns chord height (\"sagitta\") of the arc\r\n         * @returns {number}\r\n         */\r\n        chordHeight() {\r\n            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between arc and other shape\r\n         * @param {Shape} shape Shape of the one of supported types Line, Circle, Segment, Arc <br/>\r\n         * TODO: support Polygon and Planar Set\r\n         * @returns {Points[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Arc.intersectArc2Circle(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Arc.intersectArc2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from arc to shape\r\n         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.arc2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.arc2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.arc2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n         * @returns {Arcs[]}\r\n         */\r\n        breakToFunctional() {\r\n            let func_arcs_array = [];\r\n            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];\r\n            let pts = [\r\n                this.pc.translate(this.r,0),\r\n                this.pc.translate(0,this.r),\r\n                this.pc.translate(-this.r,0),\r\n                this.pc.translate(0,-this.r)\r\n            ];\r\n\r\n            // If arc contains extreme point,\r\n            // create test arc started at start point and ended at this extreme point\r\n            let test_arcs = [];\r\n            for (let i=0; i < 4; i++) {\r\n                if (pts[i].on(this)) {\r\n                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n                }\r\n            }\r\n\r\n            if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n                func_arcs_array.push(this.clone());\r\n            }\r\n            else {                                        // arc passes extreme point\r\n                // sort these arcs by length\r\n                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n                for (let i = 0; i < test_arcs.length; i++) {\r\n                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                    let new_arc;\r\n                    if (prev_arc) {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    else {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                        func_arcs_array.push(new_arc.clone());\r\n                    }\r\n                }\r\n\r\n                // add last sub arc\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n            return func_arcs_array;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the start point in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.pc, this.start);\r\n            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the end point in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.pc, this.end);\r\n            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Returns new arc with swapped start and end angles and reversed direction\r\n         * @returns {Arc}\r\n         */\r\n        reverse() {\r\n            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns new arc translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(vec) {\r\n            let arc = this.clone();\r\n            arc.pc = this.pc.translate(vec);\r\n            return arc;\r\n        }\r\n\r\n        static intersectArc2Arc(arc1, arc2) {\r\n            var ip = [];\r\n\r\n            if (arc1.box.notIntersect(arc2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case: overlapping arcs\r\n            // May return up to 4 intersection points\r\n            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n                let pt;\r\n\r\n                pt = arc1.start;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc1.end;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc2.start;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                pt = arc2.end;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n            let ip_tmp =  circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc1) && pt.on(arc2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectArc2Circle(arc, circle) {\r\n            let ip = [];\r\n\r\n            if (arc.box.notIntersect(circle.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Case when arc center incident to circle center\r\n            // Return arc's end points as 2 intersection points\r\n            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n                ip.push(arc.start);\r\n                ip.push(arc.end);\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = circle;\r\n            let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        definiteIntegral(ymin=0) {\r\n            let f_arcs = this.breakToFunctional();\r\n            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );\r\n            return area;\r\n        }\r\n\r\n        circularSegmentDefiniteIntegral(ymin) {\r\n            let line = new Flatten.Line(this.start, this.end);\r\n            let onLeftSide = this.pc.leftTo(line);\r\n            let segment = new Flatten.Segment(this.start, this.end);\r\n            let areaTrapez = segment.definiteIntegral(ymin);\r\n            let areaCircularSegment = this.circularSegmentArea();\r\n            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n            return area;\r\n        }\r\n\r\n        circularSegmentArea() {\r\n            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))\r\n        }\r\n\r\n        /**\r\n         * Return string to draw arc in svg\r\n         * @param {Object} attrs - json structure with attributes of svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n            let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {\r\n                let circle = new Flatten.Circle(this.pc, this.r);\r\n                return circle.svg(attrs);\r\n            }\r\n            else {\r\n                return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create arc equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.arc = (...args) => new Flatten.Arc(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a segment\r\n     * @type {Segment}\r\n     */\r\n    Flatten.Segment = class Segment {\r\n        /**\r\n         *\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Start point\r\n             * @type {Point}\r\n             */\r\n            this.ps = new Flatten.Point();\r\n            /**\r\n             * End Point\r\n             * @type {Point}\r\n             */\r\n            this.pe = new Flatten.Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {\r\n                let coords = args[0];\r\n                this.ps = new Flatten.Point(coords[0], coords[1]);\r\n                this.pe = new Flatten.Point(coords[2], coords[3]);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n                this.ps = args[0].clone();\r\n                this.pe = args[1].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 4) {\r\n                this.ps = new Flatten.Point(args[0], args[1]);\r\n                this.pe = new Flatten.Point(args[2], args[3]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone copies segment and returns a new instance\r\n         * @returns {Segment}\r\n         */\r\n        clone() {\r\n            return new Flatten.Segment(this.start, this.end);\r\n        }\r\n\r\n        /**\r\n         * Start point\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            return this.ps;\r\n        }\r\n\r\n        /**\r\n         * End point\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            return this.pe;\r\n        }\r\n\r\n\r\n        /**\r\n         * Returns array of start and end point\r\n         * @returns [Point,Point]\r\n         */\r\n        get vertices() {\r\n            return [this.ps.clone(), this.pe.clone()];\r\n        }\r\n\r\n        /**\r\n         * Length of a segment\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return this.start.distanceTo(this.end)[0];\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                Math.min(this.start.x, this.end.x),\r\n                Math.min(this.start.y, this.end.y),\r\n                Math.max(this.start.x, this.end.x),\r\n                Math.max(this.start.y, this.end.y)\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment contains point\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between segment and other shape\r\n         * @param {Shape} shape - Shape of the one of supported types Line, Circle, Segment, Arc <br/>\r\n         * TODO: support Polygon and Planar Set\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Line) {\r\n                return Segment.intersectSegment2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Segment.intersectSegment2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Segment.intersectSegment2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Segment.intersectSegment2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from segment to shape\r\n         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2segment(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.segment2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.segment2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2segment(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Return unit vector in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.end, this.start);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Returns new segment with swapped start and end points\r\n         * @returns {Segment}\r\n         */\r\n        reverse() {\r\n            return new Segment(this.end, this.start);\r\n        }\r\n\r\n        /**\r\n         * When point belongs to segment, return array of two segments split by given point,\r\n         * if point is inside segment. Returns clone of this segment if query point is incident\r\n         * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n         * @param {Point} pt Query point\r\n         * @returns {Segment[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (this.start.equalTo(this.end))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this];\r\n\r\n            return [\r\n                new Flatten.Segment(this.start, pt),\r\n                new Flatten.Segment(pt, this.end)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the segment\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);\r\n        }\r\n\r\n        distanceToPoint(pt) {\r\n            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n            return dist;\r\n        };\r\n\r\n        definiteIntegral(ymin = 0.0) {\r\n            let dx = this.end.x - this.start.x;\r\n            let dy1 = this.start.y - ymin;\r\n            let dy2 = this.end.y - ymin;\r\n            return ( dx * (dy1 + dy2) / 2 );\r\n        }\r\n\r\n        /**\r\n         * Returns new segment translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(vec) {\r\n            return new Segment(this.ps.translate(vec), this.pe.translate(vec));\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment start is equal to segment end up to DP_TOL\r\n         * @returns {boolean}\r\n         */\r\n        isZeroLength() {\r\n            return this.ps.equalTo(this.pe)\r\n        }\r\n\r\n        static intersectSegment2Line(seg, line) {\r\n            let ip = [];\r\n\r\n            // Boundary cases\r\n            if (seg.ps.on(line)) {\r\n                ip.push(seg.ps);\r\n            }\r\n            // If both ends lay on line, return two intersection points\r\n            if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n                ip.push(seg.pe);\r\n            }\r\n\r\n            if (ip.length > 0) {\r\n                return ip;          // done, intersection found\r\n            }\r\n\r\n            // If zero-length segment and nothing found, return no intersections\r\n            if (seg.isZeroLength()) {\r\n                return ip;\r\n            }\r\n\r\n            // Not a boundary case, check if both points are on the same side and\r\n            // hence there is no intersection\r\n            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n                return ip;\r\n            }\r\n\r\n            // Calculate intersection between lines\r\n            let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n            return line1.intersect(line);\r\n        }\r\n\r\n        static intersectSegment2Segment(seg1, seg2) {\r\n            let ip = [];\r\n\r\n            // quick reject\r\n            if (seg1.box.notIntersect(seg2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg1 zero length\r\n            if (seg1.isZeroLength()) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg2 zero length\r\n            if (seg2.isZeroLength()) {\r\n                if (seg2.ps.on(seg1)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Neither seg1 nor seg2 is zero length\r\n            let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n            let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n            // Check overlapping between segments in case of incidence\r\n            // If segments touching, add one point. If overlapping, add two points\r\n            if (line1.incidentTo(line2)) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                if (seg1.pe.on(seg2)) {\r\n                    ip.push(seg1.pe);\r\n                }\r\n                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.pe);\r\n                }\r\n            }\r\n            else {                /* not incident - parallel or intersect */\r\n                // Calculate intersection between lines\r\n                let new_ip = line1.intersect(line2);\r\n                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n                    ip.push(new_ip[0]);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectSegment2Circle(segment, circle) {\r\n            let ips = [];\r\n\r\n            if (segment.box.notIntersect(circle.box)) {\r\n                return ips;\r\n            }\r\n\r\n            // Special case of zero length segment\r\n            if (segment.isZeroLength()) {\r\n                let [dist,shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n                if (Flatten.Utils.EQ(dist, circle.r)) {\r\n                    ips.push(segment.ps);\r\n                }\r\n                return ips;\r\n            }\r\n\r\n            // Non zero-length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n            let ips_tmp = line.intersect(circle);\r\n\r\n            for (let ip of ips_tmp) {\r\n                if (ip.on(segment)) {\r\n                    ips.push(ip);\r\n                }\r\n            }\r\n\r\n            return ips;\r\n        }\r\n\r\n        static intersectSegment2Arc(segment, arc) {\r\n            let ip = [];\r\n\r\n            if (segment.box.notIntersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of zero-length segment\r\n            if (segment.isZeroLength()) {\r\n                if (segment.ps.on(arc)) {\r\n                    ip.push(segment.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Non-zero length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            let ip_tmp = line.intersect(circle);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(segment) && pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n\r\n        }\r\n\r\n        /**\r\n         * Return string to draw segment in svg\r\n         * @param {Object} attrs - Object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut method to create new segment\r\n     */\r\n    Flatten.segment = (...args) => new Flatten.Segment(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Arc,vector} = Flatten;\r\n    /**\r\n     * Class representing a circle\r\n     * @type {Circle}\r\n     */\r\n    Flatten.Circle = class Circle {\r\n        /**\r\n         *\r\n         * @param {Point} pc - circle center point\r\n         * @param {number} r - circle radius\r\n         */\r\n        constructor(pc, r) {\r\n            /**\r\n             * Circle center\r\n             * @type {Point}\r\n             */\r\n            this.pc = pc;\r\n            /**\r\n             * Circle radius\r\n             * @type {number}\r\n             */\r\n            this.r = r;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of a Circle\r\n         * @returns {Circle}\r\n         */\r\n        clone() {\r\n            return new Flatten.Circle(this.pc.clone(), this.r);\r\n        }\r\n\r\n        /**\r\n         * Circle center\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc;\r\n        }\r\n\r\n        /**\r\n         * Circle bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                this.pc.x - this.r,\r\n                this.pc.y - this.r,\r\n                this.pc.x + this.r,\r\n                this.pc.y + this.r\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Return true if circle contains point\r\n         * @param {Point} pt - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /**\r\n         * Transform circle to closed arc\r\n         * @param {boolean} counterclockwise\r\n         * @returns {Arc}\r\n         */\r\n        toArc(counterclockwise=true) {\r\n            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between circle and other shape\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Circle.intersectCirle2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.intersect(this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from circle to shape\r\n         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = point2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = circle2circle(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [distance, shortest_segment] = circle2line(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = segment2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = arc2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        static intersectCirle2Circle(circle1, circle2) {\r\n            let ip = [];\r\n\r\n            if (circle1.box.notIntersect(circle2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n            let r1 = circle1.r;\r\n            let r2 = circle2.r;\r\n\r\n            // Degenerated circle\r\n            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n                return ip;\r\n\r\n            // In case of equal circles return one leftmost point\r\n            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n                ip.push(circle1.pc.translate(-r1, 0));\r\n                return ip;\r\n            }\r\n\r\n            let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n                return ip;\r\n\r\n            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n                return ip;\r\n\r\n            // Normalize vector.\r\n            vec.x /= dist;\r\n            vec.y /= dist;\r\n\r\n            let pt;\r\n\r\n            // Case of touching from outside or from inside - single intersection point\r\n            // TODO: check this specifically not sure if correct\r\n            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);\r\n                ip.push(pt);\r\n                return ip;\r\n            }\r\n\r\n            // Case of two intersection points\r\n\r\n            // Distance from first center to center of common chord:\r\n            //   a = (r1^2 - r2^2 + d^2) / 2d\r\n            // Separate for better accuracy\r\n            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;\r\n\r\n            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);\r\n            let h = Math.sqrt(r1*r1 - a*a);\r\n            // let norm;\r\n\r\n            // norm = vec.rotate90CCW().multiply(h);\r\n            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            // norm = vec.rotate90CW();\r\n            pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - json structure with attributes of svg circle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     */\r\n    Flatten.circle = (...args) => new Flatten.Circle(...args);\r\n};","/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a line\r\n     * @type {Line}\r\n     */\r\n    Flatten.Line = class Line {\r\n        /**\r\n         * Line may be constructed by point and normal vector or by two points that a line passes through\r\n         * @param {Point} pt - point that a line passes through\r\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Point a line passes through\r\n             * @type {Point}\r\n             */\r\n            this.pt = new Flatten.Point();\r\n            /**\r\n             * Normal unit vector to a line\r\n             * @type {Vector}\r\n             */\r\n            this.norm = new Flatten.Vector(0,1);\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.pt = a1;\r\n                    this.norm = Line.points2norm(a1, a2);\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a1.clone();\r\n                    this.norm = a2.clone();\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a2.clone();\r\n                    this.norm = a1.clone();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns cloned new instance of a line\r\n         * @returns {Line}\r\n         */\r\n        clone() {\r\n            return new Flatten.Line(this.pt, this.norm);\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n         * @returns {number} - slope of the line\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n         * @code [A, B, C] = line.standard\r\n         * @returns {number[]} - array of coefficients\r\n         */\r\n        get standard() {\r\n            let A = this.norm.x;\r\n            let B = this.norm.y;\r\n            let C = this.norm.dot(this.pt);\r\n\r\n            return [A,B,C];\r\n        }\r\n\r\n        /**\r\n         * Return true if parallel or incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        parallelTo(other_line) {\r\n            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n        }\r\n\r\n        /**\r\n         * Returns true if incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        incidentTo(other_line) {\r\n            return ( (this.norm.equalTo(other_line.norm) || this.norm.equalTo(other_line.norm.invert())) &&\r\n                this.pt.on(other_line));\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to line\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            if (this.pt.equalTo(pt)) {\r\n                return true;\r\n            }\r\n            /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n            let vec = new Flatten.Vector(this.pt, pt);\r\n            return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points\r\n         * @param {Shape} shape - shape to intersect with of the type Line, Circle, Segment, Arc\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Line) {\r\n                return Line.intersectLine2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Line.intersectLine2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Line.intersectLine2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n         * @returns {Number}\r\n         * @returns {Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = Distance.point2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = Distance.circle2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = Distance.segment2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = Distance.arc2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw svg segment representing line inside given box\r\n         * @param {Box} box Box representing drawing area\r\n         * @param {Object} attrs - json structure with attributes of svg circle element\r\n         */\r\n        svg(box, attrs = {}) {\r\n            let ip = Line.intersectLine2Box(this, box);\r\n            if (ip.length === 0)\r\n                return \"\";\r\n            let ps = ip[0];\r\n            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );\r\n            if (pe === undefined) pe = ps;\r\n            let segment = new Flatten.Segment(ps, pe);\r\n            return segment.svg(attrs);\r\n        }\r\n\r\n        static points2norm(pt1, pt2) {\r\n            if (pt1.equalTo(pt2)) {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            let vec = new Flatten.Vector(pt1, pt2);\r\n            let unit = vec.normalize();\r\n            return unit.rotate90CCW();\r\n        }\r\n\r\n        static intersectLine2Line(line1, line2) {\r\n            let ip = [];\r\n\r\n            let [A1, B1, C1] = line1.standard;\r\n            let [A2, B2, C2] = line2.standard;\r\n\r\n            /* Cramer's rule */\r\n            let det = A1*B2 - B1*A2;\r\n            let detX = C1*B2 - B1*C2;\r\n            let detY = A1*C2 - C1*A2;\r\n\r\n            if (!Flatten.Utils.EQ_0(det)) {\r\n                let new_ip = new Flatten.Point( detX/det, detY/det );\r\n                ip.push(new_ip);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Circle(line, circle) {\r\n            let ip = [];\r\n            let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n            let dist = circle.pc.distanceTo(prj)[0];              // distance from circle center to projection\r\n\r\n            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n                ip.push(prj);\r\n            }\r\n            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n                var delta = Math.sqrt(circle.r*circle.r - dist*dist);\r\n                var v_trans, pt;\r\n\r\n                v_trans = line.norm.rotate90CCW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n\r\n                v_trans = line.norm.rotate90CW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Box(line, box) {\r\n            let pts = [\r\n                new Flatten.Point(box.xmin, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymax),\r\n                new Flatten.Point(box.xmin, box.ymax)\r\n            ];\r\n            let segs = [\r\n                new Flatten.Segment(pts[0], pts[1]),\r\n                new Flatten.Segment(pts[1], pts[2]),\r\n                new Flatten.Segment(pts[2], pts[3]),\r\n                new Flatten.Segment(pts[3], pts[0])\r\n            ];\r\n\r\n            let ips =  [];\r\n\r\n            for(let seg of segs) {\r\n                let ips_tmp = seg.intersect(line);\r\n                for (let ip of ips_tmp) {\r\n                    ips.push(ip);\r\n                }\r\n            };\r\n            return ips;\r\n        }\r\n\r\n        static intersectLine2Arc(line, arc) {\r\n            let ip = [];\r\n\r\n            if (Line.intersectLine2Box(line, arc.box).length == 0) {\r\n                return ip;\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = line.intersect(circle);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create line equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.line = (...args) => new Flatten.Line(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a vector\r\n     * @type {Vector}\r\n     */\r\n    Flatten.Vector = class Vector {\r\n        /**\r\n         * Vector may be constructed by two points, or by two float numbers\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            /* return zero vector */\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (typeof(a1) == \"number\" && typeof(a2) == \"number\") {\r\n                    this.x = a1;\r\n                    this.y = a2;\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.x = a2.x - a1.x;\r\n                    this.y = a2.y - a1.y;\r\n                    return;\r\n                }\r\n\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of Vector\r\n         * @returns {Vector}\r\n         */\r\n        clone() {\r\n            return new Vector(this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Slope of the vector in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let angle = Math.atan2(this.y, this.x);\r\n            if (angle<0) angle = 2*Math.PI + angle;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Length of vector\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.sqrt(this.dot(this));\r\n        }\r\n\r\n        /**\r\n         * Returns true if vectors are equal up to DP_TOL tolerance\r\n         * @param {Vector} v\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(v) {\r\n            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n        }\r\n\r\n        /**\r\n         * Returns new vector multiplied by scalar\r\n         * @param {number} scalar\r\n         * @returns {Vector}\r\n         */\r\n        multiply(scalar) {\r\n            return ( new Vector(scalar * this.x, scalar * this.y) );\r\n        }\r\n\r\n        /**\r\n         * Returns scalar product between two vectors <br/>\r\n         * <code>dot_product = (this * v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        dot(v) {\r\n            return ( this.x * v.x + this.y * v.y );\r\n        }\r\n\r\n        /**\r\n         * Returns vector product (magnitude) between two vectors <br/>\r\n         * <code>cross_product = (this x v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        cross(v) {\r\n            return ( this.x * v.y - this.y * v.x );\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector.<br/>\r\n         * Throw error if given vector has zero length\r\n         * @returns {Vector}\r\n         */\r\n        normalize() {\r\n            if (!Flatten.Utils.EQ_0(this.length)) {\r\n                return ( new Vector(this.x / this.length, this.y / this.length) );\r\n            }\r\n            throw Flatten.Errors.ZERO_DIVISION;\r\n        }\r\n\r\n        /**\r\n         * Returns new vector rotated by given angle, positive angle defines rotation in counter clockwise direction\r\n         * @param {number} angle - Angle in radians\r\n         * @returns {Vector}\r\n         */\r\n        rotate(angle) {\r\n            let point = new Flatten.Point(this.x, this.y);\r\n            let rpoint = point.rotate(angle);\r\n            return new Flatten.Vector(rpoint.x, rpoint.y);\r\n        }\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees counter clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CCW() {\r\n            return new Flatten.Vector(-this.y, this.x);\r\n        };\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CW() {\r\n            return new Flatten.Vector(this.y, -this.x);\r\n        };\r\n\r\n        /**\r\n         * Return inverted vector\r\n         * @returns {Vector}\r\n         */\r\n        invert() {\r\n            return new Flatten.Vector(-this.x, -this.y);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create vector equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.vector = (...args) => new Flatten.Vector(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * @param Flatten\r\n */\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     *\r\n     * Class representing a point\r\n     * @type {Point}\r\n     */\r\n    Flatten.Point = class Point {\r\n        /**\r\n         *\r\n         * @param {number} x - x-coordinate (float number)\r\n         * @param {number} y - y-coordinate (float number)\r\n         */\r\n        constructor(x = 0, y = 0) {\r\n            /**\r\n             * x-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = Number.isNaN(x) ? 0 : x;\r\n            /**\r\n             * y-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = Number.isNaN(y) ? 0: y;\r\n        }\r\n\r\n        /**\r\n         * Returns bounding box of a point\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new copied instance of point\r\n         * @returns {Point}\r\n         */\r\n        clone() {\r\n            return new Flatten.Point(this.x, this.y);\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.clone()];\r\n        }\r\n\r\n        /**\r\n         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(pt) {\r\n            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\r\n         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        lessThan(pt) {\r\n            if (Flatten.Utils.LT(this.y, pt.y))\r\n                return true;\r\n            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns new point rotated by given angle around given center point.\r\n         * If center point is omitted, rotates around zero point (0,0).\r\n         * Positive value of angle defines rotation in counter clockwise direction,\r\n         * negative angle defines rotation in clockwise clockwise direction\r\n         * @param {number} angle - angle in radians\r\n         * @param {Point} [center=(0,0)] center\r\n         * @returns {Point}\r\n         */\r\n        rotate(angle, center = {x:0, y:0}) {\r\n            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n            return new Flatten.Point(x_rot, y_rot);\r\n        }\r\n\r\n        /**\r\n         * Returns new point translated by given vector.\r\n         * Translation vector may by also defined by a pair of numbers.\r\n         * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n         * @param {number|number} - Translation vector defined as pair of numbers\r\n         * @returns {Point}\r\n         */\r\n        translate(...args) {\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns projection point on given line\r\n         * @param {Line} line Line this point be projected on\r\n         * @returns {Point}\r\n         */\r\n        projectionOn(line) {\r\n            if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n                return this.clone();\r\n\r\n            let vec = new Flatten.Vector(this, line.pt);\r\n            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n                return line.pt.clone();\r\n\r\n            let dist = vec.dot(line.norm);             // signed distance\r\n            let proj_vec = line.norm.multiply(dist);\r\n            return this.translate(proj_vec);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n         * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n         * @param {Line} line Query line\r\n         * @returns {boolean}\r\n         */\r\n        leftTo(line) {\r\n            let vec = new Flatten.Vector(line.pt, this);\r\n            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n            return onLeftSemiPlane;\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from point to shape\r\n         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Point) {\r\n                let dx = shape.x - this.x;\r\n                let dy = shape.y - this.y;\r\n                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Distance.point2line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Distance.point2circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Distance.point2segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n                // return dist;\r\n                return Distance.point2arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n                // return dist;\r\n                return Distance.point2polygon(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                return Distance.shape2planarSet(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns true if point is on a shape, false otherwise\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n         * @returns {boolean}\r\n         */\r\n        on(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.equalTo(shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof  Flatten.Segment) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return shape.contains(this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n         * Accept any valid attributes of svg elements as svg object\r\n         * Defaults attribues are: <br/>\r\n         * {\r\n         *    r:\"3\",\r\n         *    stroke:\"black\",\r\n         *    strokeWidth:\"1\",\r\n         *    fill:\"red\"\r\n         * }\r\n         * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n         * @returns {String}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Function to create point equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.point = (...args) => new Flatten.Point(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nlet Interval = class Interval {\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    get max() {\r\n        return this.high;\r\n    }\r\n\r\n    interval(low, high) {\r\n        return new Interval(low, high);\r\n    }\r\n\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    maximal_val(val1, val2) {\r\n        return Math.max(val1, val2);\r\n    }\r\n\r\n    val_less_than(val1, val2 ) {     // trait to compare max property with item ?\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\nmodule.exports = Interval;","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n'use strict';\r\n\r\n// let defaultTraits = require('../utils/numeric_traits');\r\nlet Interval = require('../classes/interval');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('../utils/constants');\r\n\r\nlet Node = class Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        return this.item.key.less_than(other_node.item.key);\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        let value_equal = true;\r\n        if (this.item.value && other_node.item.value) {\r\n            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n        }\r\n        return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let high = this.left.max.high ? this.left.max.high : this.left.max;\r\n        return val_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;\r\n        return val_less_than(search_node.item.key.high, low);\r\n    }\r\n};\r\n\r\nmodule.exports = Node;\r\n\r\n","/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\n// require(\"babel-polyfill\");\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n     * Set properties and methods\r\n     */\r\n    Flatten.PlanarSet = class PlanarSet extends Set {\r\n        /**\r\n         * Create new empty instance of PlanarSet\r\n         */\r\n        constructor() {\r\n            super();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * Add new shape to planar set and to its spatial index.<br/>\r\n         * If shape already exist, it will not be added again.\r\n         * This happens with no error, it is possible to use <i>size</i> property to check if\r\n         * a shape was actually added.<br/>\r\n         * Method returns planar set object updated and may be chained\r\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n         * @returns {PlanarSet}\r\n         */\r\n        add(shape) {\r\n            let size = this.size;\r\n            super.add(shape);\r\n            // size not changed - item not added, probably trying to add same item twice\r\n            if (this.size > size) {\r\n                let node = this.index.insert(shape.box, shape);\r\n            }\r\n            return this;         // in accordance to Set.add interface\r\n        }\r\n\r\n        /**\r\n         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n         * @param {Shape} shape - shape to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        delete(shape) {\r\n            let deleted = super.delete(shape);\r\n            if (deleted) {\r\n                this.index.remove(shape.box, shape);\r\n            }\r\n            return deleted;\r\n        }\r\n\r\n        // update(shape) {\r\n        //     if (super.has(shape)) {\r\n        //         this.delete(shape);\r\n        //     }\r\n        //     this.add(shape);\r\n        //\r\n        //     return this;\r\n        // }\r\n\r\n        clear() {\r\n\r\n        }\r\n\r\n        /**\r\n         * 2d range search in planar set.<br/>\r\n         * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n         * @param {Box} box - query box\r\n         * @returns {Shapes[]}\r\n         */\r\n        search(box) {\r\n            let resp = this.index.search(box);\r\n            return resp;\r\n        }\r\n\r\n        /**\r\n         * Point location test. Returns array of shapes which contains given point\r\n         * @param {Point} point - query point\r\n         * @returns {Array}\r\n         */\r\n        hit(point) {\r\n            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n            let resp = this.index.search(box);\r\n            return resp.filter((shape) => point.on(shape));\r\n        }\r\n\r\n        /**\r\n         * Returns svg string to draw all shapes in planar set\r\n         * @returns {String}\r\n         */\r\n        svg() {\r\n            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n            return svgcontent;\r\n        }\r\n    }\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\nmodule.exports = {\r\n    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),\r\n    ZERO_DIVISION: new Error('Zero division')\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\nconst DP_TOL = 0.000001;\r\nconst DECIMALS = 3;\r\n\r\nmodule.exports = {\r\n    DP_TOL: DP_TOL,\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    EQ_0: function(x) {\r\n        return ( (x) < DP_TOL && (x) > -DP_TOL );\r\n    },\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    EQ: function(x,y) {\r\n        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    GT: (x,y) => {\r\n        return ( (x)-(y) >  DP_TOL );\r\n    },\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    GE: (x,y) => {\r\n        return ( (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    LT: (x,y) => {\r\n        return ( (x)-(y) < -DP_TOL )\r\n    },\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    LE: (x,y) => {\r\n        return ( (x)-(y) <  DP_TOL );\r\n    }\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n'use strict';\r\n\r\nlet Utils = require(\"./utils/utils\");\r\nlet Errors = require(\"./utils/errors\");\r\n\r\n/**\r\n * FlattenJS - library for 2d geometry\r\n * @type {Flatten}\r\n */\r\nlet Flatten = class Flatten {\r\n    constructor() {\r\n        this.DP_TOL = Utils.DP_TOL;\r\n        this.CCW = true;\r\n        this.CW = false;\r\n        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n        this.PIx2 = 2 * Math.PI;\r\n        this.PI_2 = 0.5 * Math.PI;\r\n        this.INSIDE = 1;\r\n        this.OUTSIDE = 0;\r\n        this.BOUNDARY = 2;\r\n        this.CONTAINS = 3;\r\n        this.INTERLACE = 4;\r\n        this.CLIP_INSIDE = 1;\r\n        this.CLIP_OUTSIDE = 0;\r\n        this.BOOLEAN_UNION = 1;\r\n        this.BOOLEAN_INTERSECT = 2;\r\n        this.BOOLEAN_SUBTRACT = 3;\r\n        this.OVERLAP_SAME = 1;\r\n        this.OVERLAP_OPPOSITE = 2;\r\n        this.Utils = Utils;\r\n        this.Errors = Errors;\r\n    }\r\n};\r\n\r\nlet f = new Flatten();\r\n\r\nrequire(\"./data_structures/planar_set\")(f);\r\nrequire(\"./classes/point\")(f);\r\nrequire(\"./classes/vector\")(f);\r\nrequire(\"./classes/line\")(f);\r\nrequire(\"./classes/circle\")(f);\r\nrequire(\"./classes/segment\")(f);\r\nrequire(\"./classes/arc\")(f);\r\nrequire(\"./classes/box\")(f);\r\nrequire(\"./classes/edge\")(f);\r\nrequire(\"./classes/face\")(f);\r\nrequire(\"./classes/ray\")(f);\r\nrequire(\"./algorithms/ray_shooting\")(f);\r\nrequire(\"./classes/polygon\")(f);\r\nrequire(\"./algorithms/distance\")(f);\r\n\r\nmodule.exports = f;\r\n","\r\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n\"use strict\";\r\nlet Flatten = require(\"flatten-js\");\r\nlet BooleanOp = require(\"flatten-boolean-op\");\r\n\r\nlet {Point, Segment, Vector, Line, Box, Arc, Polygon, Face} = Flatten;\r\nlet {point, segment, arc, vector} = Flatten;\r\n\r\n/**\r\n * Class Offset implements offset of polygons\r\n */\r\nclass Offset {\r\n    /**\r\n     * Offset polygon by given value\r\n     * @param {Polygon} polygon - input polygon\r\n     * @param {number} value - offset value, may be positive or negative\r\n     */\r\n    static offset(polygon, value) {\r\n        let w = value;\r\n\r\n        let edges = [...polygon.edges];\r\n        let offsetPolygon = polygon.clone();\r\n        let offsetEdge;\r\n\r\n        if (w != 0) {\r\n\r\n            for (let edge of edges) {\r\n                if (edge.shape instanceof Flatten.Segment) {\r\n                    offsetEdge = Offset.offsetSegment(edge.shape, w);\r\n                }\r\n                else {\r\n                    offsetEdge = Offset.offsetArc(edge.shape, w);\r\n                }\r\n\r\n                if (w > 0) {\r\n                    offsetPolygon = BooleanOp.unify(offsetPolygon, offsetEdge);\r\n                }\r\n                else {\r\n                    offsetPolygon = BooleanOp.subtract(offsetPolygon, offsetEdge);\r\n                }\r\n            }\r\n        }\r\n\r\n        return offsetPolygon;\r\n    }\r\n\r\n    static offsetSegment(seg, value) {\r\n        let w = Math.abs(value);\r\n\r\n        let polygon = new Polygon();\r\n        let v_seg = vector(seg.start, seg.end);\r\n        let v_seg_unit = v_seg.normalize();\r\n        let v_left = v_seg_unit.rotate90CCW().multiply(w);\r\n        let v_right = v_seg_unit.rotate90CW().multiply(w);\r\n        let seg_left = seg.translate(v_left);\r\n        let seg_right = seg.translate(v_right).reverse();\r\n        let cap1 = Offset.arcSE(seg.end, seg_left.end, seg_right.start, Flatten.CW);\r\n        let cap2 = Offset.arcSE(seg.start, seg_right.end, seg_left.start, Flatten.CW);\r\n\r\n        polygon.addFace([seg_left, cap1, seg_right, cap2]);\r\n        return polygon;\r\n    }\r\n\r\n    static offsetArc(arc, value) {\r\n        let edges = [];\r\n\r\n        let w = Math.abs(value);\r\n\r\n        // Define outline polygon\r\n        let polygon = new Polygon();\r\n        let arc_cap1,arc_cap2;\r\n\r\n        let arc_outer = arc.clone();\r\n        arc_outer.r = arc.r + w;\r\n\r\n        arc_cap1 = Offset.arcStartSweep(arc.end, arc_outer.end, Math.PI, arc.counterClockwise);\r\n        arc_cap2 = Offset.arcEndSweep(arc.start, arc_outer.start, Math.PI, arc.counterClockwise);\r\n\r\n        let arc_inner = undefined;\r\n        if (arc.r > w) {\r\n            arc_inner = new Arc(arc.pc, arc.r - w, arc.endAngle, arc.startAngle,\r\n                arc.counterClockwise === Flatten.CW ? Flatten.CCW : Flatten.CW);\r\n        }\r\n        else {\r\n            // arc_inner = new Arc(arc.pc, w - arc.r, arc.startAngle, arc.endAngle, arc.counterClockwise);\r\n            arc_inner = new Segment(arc_cap1.end, arc_cap2.start);\r\n        }\r\n\r\n        polygon.addFace([arc_outer, arc_cap1, arc_inner, arc_cap2]);\r\n        [...polygon.faces][0].setArcLength();\r\n\r\n        // Create intersection points\r\n        let ips = Face.getSelfIntersections([...polygon.faces][0], polygon.edges, false);\r\n\r\n        // TODO: getSelfIntersections returns points with correspondent edges - avoid duplication\r\n        ips = ips.slice(0,ips.length/2);    // for now slice array to avoid duplication in points\r\n\r\n        let int_points = [];\r\n        let edge_cap1;\r\n        let edge_cap2;\r\n\r\n        edge_cap1 = [...polygon.edges][1];\r\n        edge_cap2 = [...polygon.edges][3];\r\n\r\n        for (let pt of ips) {\r\n            BooleanOp.addToIntPoints(edge_cap1, pt, int_points);\r\n            BooleanOp.addToIntPoints(edge_cap2, pt, int_points);\r\n        }\r\n\r\n        // Sort intersection points and insert them as new vertices\r\n        let int_points_sorted = BooleanOp.getSortedArray(int_points);\r\n        BooleanOp.splitByIntersections(polygon, int_points_sorted);\r\n\r\n\r\n        // Set BV flags\r\n        let bv = Flatten.OUTSIDE;\r\n        for (let int_point of int_points_sorted) {\r\n            int_point.edge_before.bv = bv;\r\n            int_point.edge_after.bv = (bv == Flatten.OUTSIDE ? Flatten.INSIDE : Flatten.OUTSIDE);\r\n            bv = int_point.edge_after.bv;   // invert flag on each iteration\r\n        }\r\n\r\n        // Remove inner \"chains\"\r\n        let op = Flatten.BOOLEAN_UNION;\r\n        BooleanOp.removeNotRelevantChains(polygon, op, int_points_sorted, true);\r\n\r\n        // return int_points_sorted;\r\n        // Swap links\r\n        let num = int_points.length;\r\n        if (num > 0) {\r\n            let edge_before;\r\n            let edge_after;\r\n            // 0 => 3\r\n            edge_before = int_points_sorted[0].edge_before;\r\n            edge_after = int_points_sorted[num-1].edge_after;\r\n            edge_before.next = edge_after;\r\n            edge_after.prev = edge_before;\r\n\r\n            // Fill in missed links in intersection points\r\n            int_points_sorted[0].edge_after = int_points_sorted[num-1].edge_after;\r\n            int_points_sorted[num-1].edge_before = int_points_sorted[0].edge_before;\r\n\r\n            if (num == 4) {\r\n                // 2 => 1\r\n                edge_before = int_points_sorted[2].edge_before;\r\n                edge_after = int_points_sorted[1].edge_after;\r\n                edge_before.next = edge_after;\r\n                edge_after.prev = edge_before;\r\n\r\n                // Fill in missed links in intersection points\r\n                int_points_sorted[2].edge_after = int_points_sorted[1].edge_after;\r\n                int_points_sorted[1].edge_before = int_points_sorted[2].edge_before;\r\n            }\r\n\r\n            // remove old faces\r\n            BooleanOp.removeOldFaces(polygon, int_points);\r\n            // restore faces\r\n            BooleanOp.restoreFaces(polygon, int_points, int_points);\r\n        }\r\n\r\n        let face0 = [...polygon.faces][0];\r\n        if (face0.orientation() === Flatten.ORIENTATION.CCW) {\r\n            polygon.reverse();\r\n        }\r\n        return polygon;\r\n    }\r\n\r\n    static arcSE(center, start, end, counterClockwise) {\r\n        let startAngle = vector(center,start).slope;\r\n        let endAngle = vector(center, end).slope;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2*Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, start).length;\r\n\r\n        return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n\r\n    static arcStartSweep(center, start, sweep, counterClockwise) {\r\n        let startAngle = vector(center,start).slope;\r\n        let endAngle = startAngle + sweep;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2*Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, start).length;\r\n\r\n        return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n\r\n    static arcEndSweep(center, end, sweep, counterClockwise) {\r\n        let {vector, Arc} = Flatten;\r\n        let endAngle = vector(center,end).slope;\r\n        let startAngle = endAngle - sweep;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2*Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, end).length;\r\n\r\n        return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n}\r\n\r\nFlatten.Polygon.prototype.offset = function(value) {\r\n    return Offset.offset(this, value);\r\n};\r\n\r\nmodule.exports = Offset;\r\n\r\n"],"sourceRoot":""}